<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Harvey's Tech Site]]></title>
  <link href="https://blog.luckyowl.me/atom.xml" rel="self"/>
  <link href="https://blog.luckyowl.me/"/>
  <updated>2025-08-12T21:12:43-07:00</updated>
  <id>https://blog.luckyowl.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[git is lost after upgrading Mac OS]]></title>
    <link href="https://blog.luckyowl.me/16631732871567.html"/>
    <updated>2022-09-14T09:34:47-07:00</updated>
    <id>https://blog.luckyowl.me/16631732871567.html</id>
    <content type="html"><![CDATA[
<p>I realized my git was not working when I executed `git status. It was all of a sudden to me because I did nothing, and I was in the middle of an important job. I have to complain about this to Apple.</p>
<p>I got this popup message &quot;The &quot;git&quot; command requires the command line developer tools...&quot;. And when I successfully installed the Command Line Developer Tools again, it won't resolve this problem. The popup message will pop up again and again. I tried to download the &quot;Command Line Developer Tools&quot; from Apple's website and install it manually with no luck.</p>
<p>After searching online, I noticed that other people ran into this issue in the past too. That means this case happens not only on this version (Monterey) but also on previous versions.</p>
<p>Finally, I found this work for me.</p>
<pre><code class="language-plain_text">sudo xcode-select -switch /Library/Developer/CommandLineTools
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up Windows Command-Line Working Env for Linux-like OS guys]]></title>
    <link href="https://blog.luckyowl.me/16521441223749.html"/>
    <updated>2022-05-09T17:55:22-07:00</updated>
    <id>https://blog.luckyowl.me/16521441223749.html</id>
    <content type="html"><![CDATA[
<h2><a id="motivation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation</h2>
<p>For developers who are accustomed to Linux-like OS systems, Windows 10 is not a productive working environment. This toolset will make their eyes shine. Because it is providing an equivalent experience to working in Mac OS with iTerms2+Oh-my-zsh equipped.</p>
<h2><a id="final-result-screenshot" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Final Result Screenshot</h2>
<p><img src="https://i.imgur.com/mSBv1Hy.png" alt="Xnip2022-05-09_14-52-38" /></p>
<p>Explanation:</p>
<ul>
<li><code>cdcode</code> and <code>gst</code> are my aliases for entering the EMS project folder and executing <code>git status</code></li>
<li><code>ipconfig</code> is a Windows built-in command-line tool used for showing information of network interfaces. Whereas <code>grep</code> is a Linux built-in command-line tool used for printing lines that match patterns which could not be used in Windows before, no matter how desperately a Linux-like OS developer wanted to use it. However, with <code>WSL</code> installed, it has become a reality to execute Linux commands directly in Windows now. <code>dig</code> is another similar example of executing Linux commands in Windows.</li>
</ul>
<h2><a id="features-at-a-glance" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features at a glance</h2>
<ul>
<li>define command aliases</li>
<li>use Linux built-in command-line tools directly</li>
<li>mixed use Windows PowerShell and Linux command line directives</li>
<li>selection as a copy</li>
<li>git status support</li>
<li>tabs</li>
<li>split panes<br />
...</li>
</ul>
<h2><a id="installation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>
<h3><a id="1-install-powershell" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Install PowerShell</h3>
<p>PowerShell is shipped with most Windows 10 distributions. If you already have it, don't bother to install it again, unless you want to use <a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2">PowerShell 7.x</a> which is not installed by default.</p>
<h3><a id="2-install-wsl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Install WSL</h3>
<p>WSL is short for &quot;Windows subsystems for Linux&quot;. It will enable you to use Linux tools in Windows. To install it is quite easy, just execute <code>wsl --install</code> in PowerShell. Go to <a href="https://docs.microsoft.com/en-us/windows/wsl/install">here</a> for more details.</p>
<h3><a id="3-install-windows-terminal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Install Windows Terminal</h3>
<p>Microsoft’s new Windows Terminal is finally stable. Windows finally has a more modern terminal environment including features like tabs, split panes, multiple session types, and settings that let you configure everything from keyboard shortcuts to animated GIF backgrounds. This is an alternative tool to iTerm2 in Mac. It is a console enhancement tool, so it must run based on one of your existing command-line shell instances, such as PowerShell.<br />
You can get it from <a href="https://www.microsoft.com/en-us/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab">Microsoft Store</a><br />
Please google its configuration details. It's up to you how deeply custom configuration you like to do.</p>
<h3><a id="4-install-oh-my-posh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Install Oh-My-Posh</h3>
<p>With the previous 3 steps, you are now having a modern terminal in Windows. Now it's time that we customize the command line prompt to make the terminal working environment more powerful. Oh-My-Posh is a custom prompt engine for any shell that has the ability to adjust the prompt string with a function or variable.<br />
Get Oh-My-Posh and its documentation from its <a href="https://ohmyposh.dev/">official website</a><br />
Now, you can use the full-colour set of your terminal, adjust existing themes or create your own, and keep track of git status automatically.<br />
To switch between the pre-defined themes, execute the following command and replace <code>theme_name</code> with your favourite theme.</p>
<pre><code class="language-plain_text">oh-my-posh init pwsh --config C:\Users\wharvey\AppData\Local\Programs\oh-my-posh\themes\{theme_name}.omp.json | Invoke-Expression
</code></pre>
<h2><a id="conclusion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h2>
<p>With the power of <code>WSL</code>, we can now use Linux tools in Windows directly.<br />
Windows Terminal is a modern terminal tool enabling developers to use tabs, multiple panes, background images and much other advanced functionality. Windows Terminal is based on command-line shell instances, such as PowerShell.<br />
Oh-My-Posh is an extension to the command-line shell. It enables developers to make good use of the command line prompt.<br />
Enjoy this toolset!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Mac Env]]></title>
    <link href="https://blog.luckyowl.me/16387363723416.html"/>
    <updated>2021-12-05T12:32:52-08:00</updated>
    <id>https://blog.luckyowl.me/16387363723416.html</id>
    <content type="html"><![CDATA[
<h1><a id="1-fundamental-env" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Fundamental Env</h1>
<h2><a id="home-brew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>home brew</h2>
<p><a href="https://brew.sh">Homebrew</a></p>
<h2><a id="iterm2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iterm2</h2>
<p><a href="http://blog.luckyowl.tech/15588383364141.html">(2) MAC开发环境--终端+Shell</a></p>
<p>Preferences→Appearance→General→Theme→Minimal</p>
<p>Preferences→Profiles→Session→Status bar enabled</p>
<h2><a id="git" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>git</h2>
<p>built-in</p>
<h2><a id="ruby" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby</h2>
<p>built-in</p>
<h2><a id="curl" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>curl</h2>
<p>built-in</p>
<h2><a id="postman" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Postman</h2>
<p><a href="https://www.postman.com/downloads/">Download Postman | Get Started for Free</a></p>
<h2><a id="testmate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testmate</h2>
<p><a href="https://macromates.com/download">Download</a></p>
<span id="more"></span><!-- more -->
<h1><a id="2-must-install-mac-tools" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Must Install Mac Tools</h1>
<h2><a id="spectacle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Spectacle</h2>
<p><a href="https://www.spectacleapp.com">Spectacle</a></p>
<h2><a id="xnip-pro" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xnip pro</h2>
<p>App Store - <a href="mailto:harveywong82@icloud.com">harveywong82@icloud.com</a></p>
<h2><a id="wallpaper-wizard-2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wallpaper Wizard 2</h2>
<p><a href="https://macpaw.com/wallpaper-wizard">Wallpaper Wizard 2: Beautiful Backgrounds for Mac</a></p>
<p>activate by email</p>
<h2><a id="clean-my-mac" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clean My Mac</h2>
<p>App Store - <a href="mailto:harveywong82@icloud.com">harveywong82@icloud.com</a></p>
<h2><a id="scroll-reverser" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scroll Reverser</h2>
<p><a href="https://pilotmoon.com/scrollreverser/">Scroll Reverser</a></p>
<h1><a id="3-productivity-tools" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Productivity Tools</h1>
<h2><a id="notion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notion</h2>
<p><a href="https://www.notion.so/desktop">Notion - The all-in-one workspace for your notes, tasks, wikis, and databases.</a></p>
<h2><a id="mweb-pro" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MWeb pro</h2>
<p>App Store - <a href="mailto:harveywong82@icloud.com">harveywong82@icloud.com</a></p>
<h2><a id="macdown" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Macdown</h2>
<p><a href="https://macdown.uranusjr.com/">MacDown: The open source Markdown editor for macOS</a></p>
<h2><a id="sidekick" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sidekick</h2>
<p><a href="https://www.meetsidekick.com/download">Download Sidekick</a></p>
<h1><a id="4-javascript-react-js-node-js-env" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. javascript, React.js, Node.js env</h1>
<h2><a id="nvm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>nvm</h2>
<p><a href="https://github.com/nvm-sh/nvm#installing-and-updating">GitHub - nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions</a></p>
<h2><a id="yarn" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>yarn</h2>
<p><code>brew install yarn</code></p>
<h1><a id="5-reactnative-env" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. ReactNative env</h1>
<p><a href="https://reactnative.dev/docs/environment-setup">Setting up the development environment · React Native</a></p>
<h2><a id="xcode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xcode</h2>
<p>App Store - <a href="mailto:harveywong82@icloud.com">harveywong82@icloud.com</a></p>
<h2><a id="command-line-tools" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Command Line Tools</h2>
<p>Open Xcode, then choose &quot;Preferences...&quot; from the Xcode menu. Go to the Locations panel and install the tools by selecting the most recent version in the Command Line Tools dropdown.</p>
<h2><a id="ios-simulator" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iOS Simulator</h2>
<p>open <strong>Xcode &gt; Preferences...</strong> and select the <strong>Components</strong> tab. Select a simulator with the corresponding version of iOS you wish to use.</p>
<h2><a id="watchman" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>watchman</h2>
<p><code>brew install watchman</code></p>
<h2><a id="cocoapods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CocoaPods</h2>
<p>brew install cocoapods</p>
<p><a href="https://cocoapods.org/">CocoaPods.org</a></p>
<h2><a id="react-native-command-line-interface" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>React Native Command Line Interface</h2>
<p>It's not necessary to install anything onto your device, just use npx.</p>
<p>If you use the Yarn package manager, you can use <code>yarn</code> instead of <code>npx</code> when running React Native commands inside an existing project.</p>
<h1><a id="6-backend-env" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. Backend Env</h1>
<h2><a id="mysql-client" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MySQL-Client</h2>
<p><code>brew insall mysql-client</code></p>
<h2><a id="mysql-server" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MySQL-Server</h2>
<p><code>brew install mysql</code></p>
<h2><a id="redis" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redis</h2>
<p><code>brew install redis</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(3) 我的MAC开发环境]]></title>
    <link href="https://blog.luckyowl.me/16129809371350.html"/>
    <updated>2021-02-10T10:15:37-08:00</updated>
    <id>https://blog.luckyowl.me/16129809371350.html</id>
    <content type="html"><![CDATA[
<p>iterm2<br />
brew<br />
yarn<br />
jenv<br />
nvm<br />
npm<br />
Intellij IDEA<br />
PyCharm<br />
GoLand<br />
Visual Studio Code<br />
Android Studio<br />
yarn global add react-devtools</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim实用高级命令]]></title>
    <link href="https://blog.luckyowl.me/15961083014557.html"/>
    <updated>2020-07-30T04:25:01-07:00</updated>
    <id>https://blog.luckyowl.me/15961083014557.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>光标移动</h2>
<ul>
<li>下一个当前单词：*</li>
<li>上一个当前单词：#</li>
<li>下一个单词第一个字符：w</li>
<li>当前单词最后一个字符：e</li>
<li>下一个以空白字符为分隔的单词第一个字符：W</li>
<li>当前以空白字符为分隔的单词最后一个字符：E</li>
<li>前一个单词第一个字符：b</li>
<li>前一个以空白字符为分隔的单词第一个字符：B</li>
<li>下一个特定字符之前：t+字符 till</li>
<li>上一个特定字符之后：T+字符</li>
<li>下一个特定字符之上：f+字符 find</li>
<li>上一个特定字符之上：F+字符</li>
<li>当前行最后一个字符上：$</li>
<li>当前行最后一个非空字符上：g_</li>
<li>当前行第一个字符上：0</li>
<li>当前行第一个非空字符上：^</li>
<li>第一行：gg 或 :1</li>
<li>最后一行：G</li>
<li>第N行： :N</li>
<li>迅速移动到下一句开头：）</li>
<li>迅速移动到上一句开头：（</li>
<li>迅速移动到下一段开头：}</li>
<li>迅速移动到上一段开头：{</li>
</ul>
<h2><a id="%E6%BB%9A%E5%8A%A8%E5%B1%8F%E5%B9%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滚动屏幕</h2>
<ul>
<li>向下翻页：<code>&lt;C+f&gt;</code> forward</li>
<li>向上翻页：<code>&lt;C+b&gt;</code> backward</li>
<li>向下翻半页：<code>&lt;C+d&gt;</code> down</li>
<li>向上翻半页：<code>&lt;C+u&gt;</code> up</li>
<li>光标不动，向下逐行滚动：<code>&lt;C+e&gt;</code> elder</li>
<li>光标不动，向上逐行滚动：<code>&lt;C+y&gt;</code> younger</li>
<li>光标不动，使光标所在行翻到屏幕最上方：zt title</li>
<li>光标不动，使光标所在行翻到屏幕最下方：zb bottom</li>
<li>光标不动，使光标所在行翻到屏幕中间：zz</li>
<li>使光标移动到屏幕最上方：H high</li>
<li>使光标移动到屏幕最下方：L low</li>
<li>使光标移动到屏幕中间：M middle</li>
</ul>
<h2><a id="%E6%96%87%E6%9C%AC%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本修改</h2>
<ul>
<li>d 加动作来进行删除（dd 删除整行）；D 则相当于 d$，删除到行尾。</li>
<li>c 加动作来进行修改（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模式。</li>
<li>s 相当于 cl，删除一个字符然后进入插入模式；S 相当于 cc，替换整行的内容。</li>
<li>i 在当前字符前面进入插入模式；I 则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</li>
<li>a 在当前字符后面进入插入模式；A 相当于 $a，把光标移到行尾然后进入插入模式。</li>
<li>o 在当前行下方插入一个新行，然后在这行进入插入模式；O 在当前行上方插入一个新行，然后在这行进入插入模式。</li>
<li>r 替换光标下的字符；R 则进入替换模式，每次按键（直到 ）替换一个字符。</li>
<li>u 撤销最近的一个修改动作；U 撤销当前行上的所有修改。</li>
<li>gU gu 使用v选中字符后，输入gU或gu可使选中文本变成大写或小写</li>
</ul>
<h2><a id="%E6%96%87%E6%9C%AC%E9%80%89%E6%8B%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本选择</h2>
<ul>
<li>i: 如：di), 删除()内所有内容，不包括()</li>
<li>a: 如：ca&quot;, 修改&quot;&quot;内包括&quot;&quot;在内的所有内容</li>
<li>用v选中后
<ul>
<li>&lt; &gt;, 左右缩进</li>
<li>= 自动缩进</li>
<li>J 内联成一行</li>
</ul>
</li>
<li>[C-v], 选中多行文本
<ul>
<li>用A或I插入文本，输入ESC，会在选中的多行文本重复执行相同插入文本操作</li>
</ul>
</li>
</ul>
<h2><a id="%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重复执行</h2>
<ul>
<li>; 重复最近的字符查找（f、t 等）操作</li>
<li>, 重复最近的字符查找操作，反方向</li>
<li>n 重复最近的字符串查找操作（/ 和 ?）</li>
<li>N 重复最近的字符串查找操作（/ 和 ?），反方向</li>
<li>. 重复执行最近的修改操作</li>
</ul>
<h2><a id="%E5%A4%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多文件操作</h2>
<ul>
<li>:args 列出打开文件列表</li>
<li>:n 打开下一个文件</li>
<li>:N 打开上一个文件</li>
<li>:ls 列出缓冲区列表</li>
<li>:bnext 切换到下一个缓冲区</li>
<li>:bprev 切换到前一个缓冲区</li>
<li>:b 序号 切换到对应序号的缓冲区</li>
<li>[C-^] 在最近编辑的文件之间切换Aug 16, 2020S</li>
</ul>
<h2><a id="%E5%A4%9A%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多窗口操作</h2>
<ul>
<li>:sp 或 [C+w]s 水平拆分</li>
<li>:vs 或 [C+w]v 垂直拆分</li>
<li>[C+w]w 窗口切换</li>
<li>[C+w]c 关闭窗口，最后一个窗口无效</li>
<li>[C+w]q 退出窗口，最后一个窗口退出整个vim</li>
<li>[C+w]= 平均调整每个窗口大小</li>
<li>:tabnew 新建标签页</li>
<li>:gt, :gT 切换标签页</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些终端下更好用的替代工具]]></title>
    <link href="https://blog.luckyowl.me/15949090783980.html"/>
    <updated>2020-07-16T07:17:58-07:00</updated>
    <id>https://blog.luckyowl.me/15949090783980.html</id>
    <content type="html"><![CDATA[
<h2><a id="ls%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ls的替代工具</h2>
<pre><code class="language-plain_text"># brew info exa
</code></pre>
<pre><code class="language-plain_text"># exa -l --tree -L 1
</code></pre>
<p>用列表加树状展示一级目录下的目录和文件</p>
<h2><a id="cat%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cat的替代工具</h2>
<pre><code class="language-plain_text"># brew info bat
</code></pre>
<pre><code class="language-plain_text"># bat README.md
</code></pre>
<p>比cat增加高亮和对git状态的支持</p>
<h2><a id="find%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>find的替代工具</h2>
<pre><code class="language-plain_text"># brew info fd
</code></pre>
<pre><code class="language-plain_text"># fd README.md
</code></pre>
<p>语法比find简单，默认忽略.gitignore里的文件和隐藏文件</p>
<h2><a id="grep%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>grep的替代工具</h2>
<pre><code class="language-plain_text"># brew info rg
</code></pre>
<pre><code class="language-plain_text"># rg xxx
</code></pre>
<p>显示漂亮，默认忽略.gitignore文件和隐藏文件，默认递归所有子文件夹，可以指定文件类型</p>
<h2><a id="cd%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cd的替代工具</h2>
<pre><code class="language-plain_text"># brew info z
</code></pre>
<pre><code class="language-plain_text"># z de [Tab]
</code></pre>
<p>自动基于历史访问过的以de开头的目录进行补全</p>
<pre><code class="language-plain_text"># brew info fzf
</code></pre>
<pre><code class="language-plain_text"># cd $(find * -type d | fzf)
</code></pre>
<p>通过上下键选择需要访问的目录，回车进入。</p>
<p>fzf会把标准输出变成交互式下拉列表共用户选择。</p>
<h2><a id="%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件管理的替代工具</h2>
<pre><code class="language-plain_text"># brew info nnn
</code></pre>
<h2><a id="%E7%9C%8B%E6%97%A5%E5%BF%97tail%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>看日志tail的替代工具</h2>
<pre><code class="language-plain_text"># brew info lnav
</code></pre>
<p>支持各种日志的高亮显示，支持正则匹配</p>
<h2><a id="man%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>man的替代工具</h2>
<pre><code class="language-plain_text"># brew info
</code></pre>
<hr />
<p><img src="http://image.harveygg.wang/mweb/15951458383567.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全和隐私中“任何来源”找回办法]]></title>
    <link href="https://blog.luckyowl.me/15750321018543.html"/>
    <updated>2019-11-29T04:55:01-08:00</updated>
    <id>https://blog.luckyowl.me/15750321018543.html</id>
    <content type="html"><![CDATA[
<p>苹果发布了<code>MacOS Sierra 10.12</code>版本之后，原来需要用于安装从网上下载的软件的功能不见了，即系统中“任何来源”选项。可以使用如下方法找回“任何来源”的选项。</p>
<p>在终端中输入</p>
<pre><code class="language-shell">sudo spctl --master-disable
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC使用技巧]]></title>
    <link href="https://blog.luckyowl.me/15616863130414.html"/>
    <updated>2019-06-27T18:45:13-07:00</updated>
    <id>https://blog.luckyowl.me/15616863130414.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；</li>
<li>finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹；</li>
<li>恢复备份时的默认密码是：0000</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(2) MAC开发环境——终端+Shell]]></title>
    <link href="https://blog.luckyowl.me/15588383364141.html"/>
    <updated>2019-05-25T19:38:56-07:00</updated>
    <id>https://blog.luckyowl.me/15588383364141.html</id>
    <content type="html"><![CDATA[
<p><img src="https://i.imgur.com/YQ9qFFq.jpg" alt="Jietu20190526-225814" /></p>
<p>最终效果！</p>
<h2><a id="iterm2-https-iterm2-com" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://iterm2.com/">iTerm2</a></h2>
<p><img src="https://i.imgur.com/psy3faV.jpg" alt="iter" /></p>
<p>iTerm2 是 MAC 下最好的终端工具。<br />
可以使用Homebrew来安装：</p>
<pre><code class="language-shell">$ brew cask install iterm2
</code></pre>
<hr />
<p>iTerm2 的一些特色功能如下。</p>
<h3><a id="%E6%A0%87%E7%AD%BE%E5%8F%98%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标签变色</h3>
<p>iTerm2的tab会通过变色来提示当前tab下的任务有新活动，有新的输出时tab会变成洋红色，新的输出长时间没看，tab会变成红色。</p>
<h3><a id="%E6%99%BA%E8%83%BD%E9%80%89%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>智能选中</h3>
<p>在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）</p>
<p>在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。</p>
<p>使用CMD+F打开搜索，然后输入需要复制的内容开头关键字，如IP的第一节，搜到后按Tab键，智能选中需要复制的内容并且已经拷贝到剪贴板。</p>
<h3><a id="%E5%B7%A7%E7%94%A8%E2%8C%98cmd%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>巧用⌘(CMD)键</h3>
<p>按住⌘键:</p>
<ul>
<li>可以拖拽选中的字符串；</li>
<li>点击url：调用默认浏览器访问该网址；</li>
<li>点击文件：调用默认程序打开文件；</li>
<li>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；</li>
<li>点击文件夹：在 finder 中打开该文件夹；</li>
</ul>
<h3><a id="%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用快捷键</h3>
<ul>
<li>切换tab：<code>⌘+←</code>, <code>⌘+→</code>, <code>⌘+{</code>, <code>⌘+}</code>。⌘+数字直接定位到该tab；</li>
<li>新建 tab：<code>⌘+t</code>；</li>
<li>顺序切换pane：<code>⌘+[</code>, <code>⌘+]</code>；</li>
<li>切分屏幕：<code>⌘+d</code>水平切分，<code>⌘+shift+d</code> 垂直切分；</li>
<li>按方向切换pane：<code>⌘+Option+方向键</code>；</li>
<li>智能查找，支持正则查找：<code>⌘+f</code>；</li>
<li>显示光标位置：<code>⌘+/</code></li>
<li>增加标记，然后跳回标记：<code>⌘+shift+M</code>标记，<code>⌘+shift+J</code>跳回标记，<code>⌘+shift+up/down</code>在标记间切换</li>
<li>显示历史剪贴板所有内容：<code>⌘+shift+H</code></li>
<li>按时间轴显示快照：<code>⌘+option+B</code></li>
</ul>
<h3><a id="%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动完成</h3>
<p>iTerm2可以自动补齐命令，输入若干字符，按<code>⌘+;</code>弹出自动补齐窗口，列出曾经使用过的命令。</p>
<h3><a id="%E9%85%8D%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配色</h3>
<p>你可以自由定制喜欢的配色，<a href="https://iterm2colorschemes.com/">这里</a>收集了大量iTerm2的主题。在其github repo里下载对应的xxx.itermcolors文件安装，安装方法如下：</p>
<ul>
<li>打开iTerm2</li>
<li>按<code>⌘+i</code></li>
<li>选中<code>Colors</code>tab</li>
<li>点击<code>Load Presets</code></li>
<li>点击<code>Import</code></li>
<li>选择你需要的<code>.itermcolors</code>文件</li>
<li>再次点击<code>Load Presets</code>选择刚刚导入的主题</li>
</ul>
<hr />
<p>但是最理想的配色方案在这里<a href="https://github.com/altercation/solarized">https://github.com/altercation/solarized</a></p>
<pre><code class="language-shell">$ git clone https://github.com/altercation/solarized.git
</code></pre>
<ol>
<li>进入solarized/iterm2-colors-solarized 下双击<code>Solarized Dark.itermcolors</code>和<code>Solarized Light.itermcolors</code>两个文件就可以把明暗两种配置文件导入到iTerm2里</li>
<li>通过load presets选择刚刚安装的配色主题即可</li>
</ol>
<p><img src="https://i.imgur.com/eaxfX0N.jpg" alt="Jietu20190527-001007" /></p>
<h2><a id="zsh-https-zhuanlan-zhihu-comp19556676" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://zhuanlan.zhihu.com/p/19556676">ZSH</a></h2>
<p>MAC默认自带终极shell!</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/21418449">为什么说zsh是shell中的极品</a></p>
</blockquote>
<p>修改默认bash</p>
<pre><code class="language-shell">$ chsh -s /bin/zsh
</code></pre>
<h3><a id="oh-my-zsh-https-ohmyz-sh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://ohmyz.sh/">Oh My ZSH</a></h3>
<p><img src="https://i.imgur.com/XZa8j9Q.png" alt="omzsh" /></p>
<blockquote>
<p>Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout...</p>
</blockquote>
<blockquote>
<p>“Oh My ZSH!”</p>
</blockquote>
<h4><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h4>
<pre><code class="language-plain_text">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
<h4><a id="%E9%85%8D%E7%BD%AEoh-my-zsh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置oh my zsh</h4>
<blockquote>
<p><a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh github</a></p>
</blockquote>
<h3><a id="agnoster%E4%B8%BB%E9%A2%98-https-github-comfcambloroh-my-zsh-agnoster-fcamblor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor">agnoster主题</a></h3>
<p>agnoster是一个zsh主题，特别为使用iTerm2 + Solarized Dark主题，又经常使用Git的用户定制。</p>
<h4><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h4>
<pre><code class="language-shell">$ git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git
</code></pre>
<p>执行工程里的install脚本，主题将安装到~/.oh-my-zsh/themes目录下</p>
<h4><a id="%E8%AE%BE%E7%BD%AE%E8%AF%A5%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置该主题</h4>
<p>打开~/.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。</p>
<h3><a id="%E5%A2%9E%E5%8A%A0%E6%8C%87%E4%BB%A4%E9%AB%98%E4%BA%AE%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增加指令高亮效果</h3>
<p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮</p>
<h4><a id="%E5%AE%89%E8%A3%85zsh-syntax-highlighting-https-github-comzsh-userszsh-syntax-highlighting" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></h4>
<pre><code class="language-shell">$ git clone git://github.com/zsh-users/zsh-syntax-highlighting.git
$ echo &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc
</code></pre>
<h3><a id="%E5%AE%89%E8%A3%85powerline-http-powerline-readthedocs-ioenlatestinstallation-html" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="http://powerline.readthedocs.io/en/latest/installation.html">安装Powerline</a></h3>
<pre><code class="language-shell">$ pip install powerline-status --user
</code></pre>
<h3><a id="%E5%AE%89%E8%A3%85powerline%E5%AD%97%E4%BD%93%E5%BA%93-https-link-jianshu-com-t-https-3a-2f-2fgithub-com-2fpowerline-2ffonts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fpowerline%2Ffonts">Powerline字体库</a></h3>
<p>使用zsh主题需要配合Powerline字体</p>
<ol>
<li>将工程clone下来</li>
<li>执行install.sh脚本安装所有Powerline字体</li>
</ol>
<p>安装完成后提示所有字体均已下载到/Users/{username}/Library/Fonts路径下</p>
<h4><a id="%E8%AE%BE%E7%BD%AEiterm2%E7%9A%84%E5%AD%97%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置iTerm2的字体</h4>
<p>具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，选择for Powerline的字体</p>
<hr />
<blockquote>
<p>Maybe you also want to try <a href="https://jmolivas.weknowinc.com/improve-your-shell-using-fish-and-oh-my-fish">this</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(1) MAC开发环境——软件包管理]]></title>
    <link href="https://blog.luckyowl.me/15587920075778.html"/>
    <updated>2019-05-25T06:46:47-07:00</updated>
    <id>https://blog.luckyowl.me/15587920075778.html</id>
    <content type="html"><![CDATA[
<hr />
<h2><a id="homebrew-https-brew-sh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://brew.sh/">Homebrew</a></h2>
<ul>
<li>使用 Homebrew 安装 Apple 没有预装，但你需要的东西。</li>
<li>brew管理命令行工具，三方库，会先下载源码，编译，安装，最后link到/usr/local/bin中，如：<code>brew install wget</code></li>
<li>brew cask管理Mac应用，会直接下载二进制，然后安装，是AppStore的补充，如：<code>brew cask install chrome</code></li>
<li>推荐所有软件<strong>先考虑AppStore</strong>，如果没有<strong>再考虑Homebrew</strong>，再没有<strong>再去官网下载</strong>，方便后面管理</li>
</ul>
<h3><a id="install-homebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Install Homebrew</h3>
<pre><code class="language-shell">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h3><a id="homebrew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew 常用命令</h3>
<pre><code class="language-shell">$ brew search /wge*/  # 搜索软件,后面是正则表达式
$ brew info wget    # 查看软件信息
$ brew install wget  # 安装 wget
$ brew list wget    # 列出该软件安装后的文件
$ brew uninstall wget  # 卸载 wget
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96homebrew-cask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取Homebrew-Cask</h3>
<pre><code class="language-shell">$ brew tap caskroom/cask
</code></pre>
<h3><a id="homebrew-cask%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew Cask常用命令</h3>
<pre><code class="language-shell"># brew cask 和 brew 的命令基本一致，search, info, list, install, uninstall 子命令都一样
$ brew cask install java  # 安装 Java
$ brew cask uninstall java  # 卸载 Java
$ brew cask install --force $(brew cask outdated | awk '{print $1}' | xargs)  # 更新Cask
</code></pre>
<h3><a id="homebrew%E6%9B%B4%E5%A4%9A%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew 更多命令</h3>
<pre><code class="language-shell">$ brew cleanup  # 卸载旧版本软件，Homebrew升级时是全新安装，不卸载旧版，需要手动卸载旧版本软件
$ brew update  # 更新Homebrew
$ brew upgrade  # 更新所有过期软件
$ brew doctor  # brew自检
$ brew outdated  # 列出所有过期软件
$ brew --cache  # 打印brew下载包存放位置
</code></pre>
<h3><a id="%E5%8D%B8%E8%BD%BDhomebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>卸载Homebrew</h3>
<pre><code class="language-shell">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)
</code></pre>
<p>Download the uninstall script and run ./uninstall --help to view more uninstall options.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate log files automatically using `pm2-logrotate`]]></title>
    <link href="https://blog.luckyowl.me/16911904976668.html"/>
    <updated>2023-08-04T16:08:17-07:00</updated>
    <id>https://blog.luckyowl.me/16911904976668.html</id>
    <content type="html"><![CDATA[
<ol>
<li>Install this module</li>
</ol>
<pre><code class="language-bash">pm2 install pm2-logrotate
</code></pre>
<ol start="2">
<li>Config this module</li>
</ol>
<p>The following is an example of configuring pm2-logrotate. Other configuration items are similar to being configured. Please check current configuration or pm2 official documentation for detailed configuration items.</p>
<pre><code class="language-plain_text">pm2 set pm2-logrotate:max_size 100M
</code></pre>
<ol start="3">
<li>Check whether this module is active</li>
</ol>
<pre><code class="language-plain_text">pm2 list
</code></pre>
<p>If this module is working you should be able to see its status in the &quot;Module&quot; section.</p>
<p><img src="https://i.imgur.com/P7bKfE3.jpg" alt="" /></p>
<ol start="4">
<li>Check current configuration of this module</li>
</ol>
<pre><code class="language-bash">pm2 conf pm2-logrotate
</code></pre>
<p><img src="https://i.imgur.com/EyRcKL7.jpg" alt="" /></p>
<ol start="5">
<li>Check logs of pm2-logrotate</li>
</ol>
<pre><code class="language-plain_text">pm2 logs pm2-logrotate
</code></pre>
<ol start="6">
<li>Reload pm2-logrotate</li>
</ol>
<pre><code class="language-plain_text">pm2 reload pm2-logrotate
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx配置文件解析算法]]></title>
    <link href="https://blog.luckyowl.me/16530220234994.html"/>
    <updated>2022-05-19T21:47:03-07:00</updated>
    <id>https://blog.luckyowl.me/16530220234994.html</id>
    <content type="html"><![CDATA[
<p>当一个请求到达时，nginx通过如下算法确定最终用哪一个block来serve这次请求。</p>
<ol>
<li>listen匹配，nginx会先把所有server的ip:port用默认值补全，然后和目标请求的ip:port匹配，匹配优先级如下
<ol>
<li>唯一完全匹配——直接选中server</li>
<li>最高匹配度的一批server——比较server_name</li>
</ol>
</li>
<li>server_name匹配
<ol>
<li>完全匹配——直接选中server</li>
<li>尝试把请求host的第前一级域名变成*号到配置中去匹配——选中server</li>
<li>尝试把请求host的最后一级域名变成*号到配置中去匹配——选中server</li>
<li>尝试把请求host与配置中正则表达式的server_name去匹配——选中server</li>
<li>选中default server</li>
</ol>
</li>
<li>location匹配
<ol>
<li>带有 = 修饰符，能完全匹配的location——直接选中</li>
<li>寻找最长的前缀匹配结果，如存在，且带有 ^~ 修饰符，直接选中，若不带修饰符，暂存，然后看正则表达式location匹配结果</li>
<li>如果前缀匹配location的暂存结果中，有能匹配到的正则表达式location，则那个location优先级置顶，最终优先级最高的location被选中</li>
<li>如果没有正则表达式location被选中，之前暂存的前缀location被选中</li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js 后端代码架构最佳实践]]></title>
    <link href="https://blog.luckyowl.me/16436139545729.html"/>
    <updated>2022-01-30T23:25:54-08:00</updated>
    <id>https://blog.luckyowl.me/16436139545729.html</id>
    <content type="html"><![CDATA[
<ul>
<li>routes按业务分成多个文件，index.js通过router.use()组合多个业务routes</li>
<li>各业务routes文件中只做把路由映射到controller的动作</li>
<li>routes按版本组织</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is a good Node.js Template in 2022]]></title>
    <link href="https://blog.luckyowl.me/16433325024079.html"/>
    <updated>2022-01-27T17:15:02-08:00</updated>
    <id>https://blog.luckyowl.me/16433325024079.html</id>
    <content type="html"><![CDATA[
<ul>
<li>Uses <a href="https://yarnpkg.com/">yarn</a></li>
<li>Organize code structure with <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecturef</a></li>
<li>Demonstrates the <a href="https://12factor.net/">twelve-factor</a> methodology</li>
<li>ES2017 latest features like Async/Await</li>
<li>Watch code changes and restart for development using <a href="https://nodemon.io/">nodemon</a>
<ul>
<li><code>yarn add nodemon --dev</code></li>
</ul>
</li>
<li>Load environment variables from .env files with <a href="https://www.npmjs.com/package/dotenv">dotenv</a></li>
<li>Web framework using <a href="https://expressjs.com/">Express</a> with middlewares as follows
<ul>
<li><code>yarn add express</code></li>
<li>Support CORS with express middleware <a href="https://expressjs.com/en/resources/middleware/cors.html">cors</a></li>
<li>Gzip compression with express middleware <a href="http://expressjs.com/en/resources/middleware/compression.html">compression</a></li>
<li>Parsing cookies with express middleware <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a>
<ul>
<li><code>yarn add cookie-parser</code></li>
</ul>
</li>
<li>Customize request logs with express middleware <a href="https://expressjs.com/en/resources/middleware/morgan.html">morgan</a>, which can be integrated with Winston.</li>
<li>Set some HTTP headers for security with <a href="https://github.com/helmetjs/helmet">helmet</a>
<ul>
<li><code>yarn add helmet</code></li>
<li><code>import helmet from 'helmet';</code></li>
<li><code>const app = express();</code></li>
<li><code>app.use(helmet());</code></li>
</ul>
</li>
</ul>
</li>
<li>Request validation with <a href="https://joi.dev/">joi</a></li>
<li>Authentication and Authorization with <a href="https://www.passportjs.org/">Passport</a>
<ul>
<li><code>yarn add passport</code></li>
</ul>
</li>
<li>MongoDB Modeling Lib with <a href="https://mongoosejs.com/">Mongoose</a>
<ul>
<li><code>yarn add mongoose</code></li>
</ul>
</li>
<li>Support pagination with <a href="https://www.npmjs.com/package/mongoose-aggregate-paginate-v2">Mongoose-aggregate-paginate-v2</a>
<ul>
<li><code>yarn add mongoose-aggregate-paginate-v2</code></li>
</ul>
</li>
<li>Deal with Date Object with <a href="https://day.js.org/">Day.js</a></li>
<li>Git hooks with <a href="https://typicode.github.io/husky/#/">husky</a></li>
<li>Linting with <a href="http://eslint.org/">ESLint</a></li>
<li>Format with <a href="https://prettier.io/">Prettier</a></li>
<li>Consistent coding styles with <a href="https://editorconfig.org/">EditorConfig</a></li>
<li>Tests with <a href="https://mochajs.org/">mocha</a>, <a href="https://www.chaijs.com/">chai</a> and <a href="https://sinonjs.org/">sinon</a></li>
<li>Code coverage with <a href="https://istanbul.js.org/">Istanbul</a> and <a href="https://coveralls.io/">coveralls</a></li>
<li>Continuous integration support with <a href="https://travis-ci.org/">Travis CI</a></li>
<li>Docker support</li>
<li>Monitoring with <a href="https://pm2.keymetrics.io/">pm2</a></li>
<li>Logging system using <a href="https://github.com/winstonjs/winston">Winston</a>
<ul>
<li><code>yarn add winston</code></li>
<li>With Winston, you can have multiple transports configured at different levels.</li>
</ul>
</li>
<li>API documentation generation with <a href="https://apidocjs.com/">apidoc</a></li>
<li></li>
<li>Image uploading with <a href="https://aws.amazon.com/tr/s3/">AWS S3 Client</a></li>
<li>Email sending by using <a href="https://sendgrid.com/">SendGrid</a> and <a href="https://aws.amazon.com/tr/ses/">AWS SES</a></li>
<li>SMS sending by using <a href="https://www.twilio.com/">Twilio</a></li>
<li>Multilanguage Support using <a href="https://www.npmjs.com/package/i18n-js">i18n</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kafka学习笔记]]></title>
    <link href="https://blog.luckyowl.me/15621674595097.html"/>
    <updated>2019-07-03T08:24:19-07:00</updated>
    <id>https://blog.luckyowl.me/15621674595097.html</id>
    <content type="html"><![CDATA[
<h2><a id="kafka%E5%90%8D%E5%AD%97%E6%9D%A5%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka名字来源</h2>
<p>Kafka作者之一Jay Kreps曾经谈及过命名的原因：</p>
<blockquote>
<p>因为 Kafka 系统的写性能很强，所以找了个作家的名字来命名似乎是一个好主意。大学期间我上了很多文学课，非常喜欢 Franz Kafka 这个作家，另外为开源软件起这个名字听上去很酷。</p>
</blockquote>
<h2><a id="kafka%E7%9A%84%E5%AE%9A%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka的定位</h2>
<p>Kafka 是 LinkedIn 公司内部孵化的项目。</p>
<p>Kafka 在设计之初就旨在提供三个方面的特性：</p>
<ul>
<li>提供一套 API 实现生产者和消费者；</li>
<li>降低网络传输和磁盘存储开销；</li>
<li>实现高伸缩性架构。</li>
</ul>
<p>Kafka既是消息引擎系统，也是一个分布式流处理平台。</p>
<h3><a id="kafka%E4%BD%9C%E4%B8%BA%E6%B5%81%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0%E5%92%8C%E5%85%B6%E4%BB%96%E4%B8%BB%E6%B5%81%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%E7%9B%B8%E6%AF%94%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka作为流处理平台和其他主流计算框架相比的优势</h3>
<ul>
<li>更容易实现端到端的正确性（精确一次处理语义）</li>
<li>Kafka Streams宣称自己是一个用于搭建流处理的客户端库，而非完整功能系统，有利于区别其他框架的目标市场（瞄准小公司）</li>
</ul>
<h2><a id="kafka%E6%9C%AF%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka术语</h2>
<h3><a id="%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8Ekafka%E6%9C%AF%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一张图说明Kafka术语</h3>
<p><img src="http://image.harveygg.wang/mweb/15621685649048.jpg" alt="" style="width:1171px;" /></p>
<ul>
<li>消息（Record）：消息引擎处理的主要对象</li>
<li>主题（Topic）：承载消息的逻辑容器，具体使用中用于区分业务</li>
<li>分区（Partition）：一个有序的消息队列，一个主题下可以有多个分区</li>
<li>消息位移（Offset）：表示分区中每条消息的位置，是一个单调递增不变的值</li>
<li>副本（Replica）：Kafka中一条消息可以被复制到多个地方实现数据冗余，这些地方就是副本。副本还分leader副本和follower副本。副本在分区的层级下，一个分区可以配置多个副本实现数据高可靠</li>
<li>生产者（Producer）：向主题发布新消息的应用程序</li>
<li>消费者（Consumer）：从主题订阅新消息的应用程序</li>
<li>消费者位移（Consumer Offset）：表征消费者的消费进度，每个消费者都有自己的消费者位移</li>
<li>消费者组（Consumer Group）：多个消费者实例共同构成一个组，同时消费多个分区实现高吞吐</li>
<li>重平衡（Rebalance）：消费者组内一个消费者实例挂掉后，其他消费者自动重新分配订阅主题分区的过程。Rebalance是Kafka实现消费者端高可用的手段</li>
</ul>
<h2><a id="%E4%B8%8D%E8%83%BD%E4%BF%9D%E6%8C%81%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不能保持默认值的参数</h2>
<h3><a id="broker%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Broker端参数</h3>
<ul>
<li>log.dirs：没有默认值，必须手动指定。CVS格式指定多个路径，且多个路径最好分布在不同磁盘上，提供读写性能和提高可用性</li>
<li>listeners：监听器，告诉外部连接者要用什么协议访问主机和端口开放的Kafka服务</li>
<li>advertised.listeners：这组监听器是Broker用于对外发布的</li>
<li>auto.create.topics.enable：配置为true时表示，当收到消息，发现所属主题不存在时则自动创建，建议生产配置false</li>
<li>unclean.leader.election.enable：是否允许unclean leader选举。是指落后最新消息的partition被选举为leader的许可。若配置为true，则有可能导致消息丢失</li>
<li>auto.leader.rebalance.enable：是否允许定期重新选举leader，没必要，且对生产环境影响非常大，建议配置false</li>
<li>log.retention.{hour|minutes|ms}：三个配置都是用来控制一条消息被保存多长时间，ms优先级最高，hour最低</li>
<li>log.retention.bytes：指Broker为消息保存的总磁盘容量大小，默认值-1，标识存多少都行</li>
<li>message.max.bytes：Broker能接收的最大消息大小</li>
</ul>
<h3><a id="topic%E7%BA%A7%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Topic级参数</h3>
<ul>
<li>retention.ms：规定了该topic消息被保存的时长，默认7天，优先级高于Broker配置</li>
<li>retention.bytes：规定了该topic预留多少磁盘空间</li>
<li>message.max.bytes：该topic下单条消息最大尺寸，可用于不同业务不同配置</li>
</ul>
<h3><a id="producer%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producer端参数</h3>
<h3><a id="consumer%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consumer端参数</h3>
<h3><a id="jvm%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM参数</h3>
<blockquote>
<p>设置环境变量，提高JVM堆大小，业界公认最佳配置为6G，修改GC算法</p>
</blockquote>
<ul>
<li>KAFKA_HEAP_OPTS：堆大小</li>
<li>KAFKA_JVM_PERFORMANCE_OPTS：GC算法</li>
</ul>
<pre><code class="language-shell">$&gt; export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g
$&gt; export  KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true
$&gt; bin/kafka-server-start.sh config/server.properties

</code></pre>
<h3><a id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>操作系统参数</h3>
<ul>
<li>文件描述符限制调大</li>
<li>文件系统类型：根据官网的测试报告，XFS 的性能要强于 ext4，<a href="https://www.confluent.io/kafka-summit-sf18/kafka-on-zfs">ZFS</a>性能貌似更好</li>
<li>Swap修改成1：改成0容易导致内存溢出来不及处理</li>
<li>文件刷盘时间间隔：消息写到页缓存上即算成功，减小刷盘间隔可以提高可用性，但是降低吞吐量</li>
</ul>
<h2><a id="%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现无消息丢失</h2>
<h3><a id="%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置最佳实践</h3>
<ol>
<li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</li>
<li>设置 acks = all。acks 是 Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li>
<li>设置 retries 为一个较大的值。这里的 retries同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li>
<li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li>
<li>设置 replication.factor &gt;= 3。这也是Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li>
<li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li>
<li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li>
</ol>
<h3><a id="%E5%B8%B8%E8%A7%81%E4%B8%A2%E6%B6%88%E6%81%AF%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见丢消息案例</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[域名解析]]></title>
    <link href="https://blog.luckyowl.me/15611719436274.html"/>
    <updated>2019-06-21T19:52:23-07:00</updated>
    <id>https://blog.luckyowl.me/15611719436274.html</id>
    <content type="html"><![CDATA[
<h2><a id="dns%E5%9F%9F%E5%90%8D%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS域名规范</h2>
<ul>
<li>域名中的标号由英文和数字组成，标号中除连字符“-”外不能使用其他的标点符号，不区分大小写字母</li>
<li>每一个标号不超过63个字符</li>
<li>级别最低的域名写在最左边，而级别最高的字符写在最右边</li>
<li>由多个标号组成的完整域名总共不超过255个字符</li>
<li>DNS既不规定一个域名需要包含多少个下级域名，也不规定每一级域名代表什么意思。</li>
<li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由ICANN进行管理</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名管理</h2>
<ul>
<li>
<p>顶级域名分三大类</p>
<ul>
<li><strong>国家顶级域名nTLD</strong>：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)</li>
<li><strong>通用顶级域名gTLD</strong>：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)</li>
<li><strong>基础结构域名(infrastructure domain)</strong>：只有一个arpa，用于反向域名解析，因此成为反向域名</li>
</ul>
<p><img src="http://image.harveygg.wang/mweb/15611724903244.jpg" alt="xxx" /></p>
</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名服务器的分类</h2>
<ul>
<li>根域名服务器：记录顶级域名服务器</li>
<li>顶级域名服务器：管理在该顶级域名服务器注册的二级域名</li>
<li>权威域名服务器(authoritative domain name system)：负责一个zone的域名解析</li>
<li>本地域名服务器：不在域名服务器树结构中，但是很重要，域名解析首先发给本地域名服务器</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名解析过程</h2>
<ol>
<li>请求本地域名服务器</li>
<li>本地域名服务器返回解析结果或想根域名服务器请求</li>
<li>根域名服务器返回顶级域名服务器的地址</li>
<li>本地域名服务器请求顶级域名服务器</li>
<li>顶级域名服务器返回权威域名服务器的地址</li>
<li>本地域名服务器请求权威域名服务器</li>
<li>权威域名服务器返回解析结果或报错</li>
<li>本地域名服务器返回解析结果或报错</li>
</ol>
<h2><a id="dns%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS记录类型</h2>
<ul>
<li>A记录：将域名指向IPv4地址</li>
<li>AAAA：将域名指向IPv6地址（例如：ff06:0:0:0:0:0:0:c3）</li>
<li>CNAME：将域名指向另一个域名</li>
<li>TXT：在这里可以填写任何东西，长度限制255字符。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）</li>
<li>NS：授权其他域名服务器解析域名</li>
<li>MX：指向邮箱服务器</li>
<li>SOA：SOA叫做起始授权机构记录，表明负责一个zone的多台权威DNS服务器（由NS记录标记）之间的关系，SOA指向的DNS有修改权，其他DNS从SOA同步数据</li>
<li>SRV记录：记录提供特定服务的服务器，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</li>
<li>PTR记录：PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDD项目目录结构示例]]></title>
    <link href="https://blog.luckyowl.me/17486246383383.html"/>
    <updated>2025-05-30T10:03:58-07:00</updated>
    <id>https://blog.luckyowl.me/17486246383383.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-plain_text">ecommerce-platform/
├── README.md
├── docker-compose.yml
├── requirements.txt
└── src/
    ├── shared/                           # 共享内核
    │   ├── __init__.py
    │   ├── domain/
    │   │   ├── __init__.py
    │   │   ├── base_entity.py
    │   │   ├── base_aggregate_root.py
    │   │   ├── domain_event.py
    │   │   ├── value_objects/
    │   │   │   ├── __init__.py
    │   │   │   ├── money.py
    │   │   │   ├── email.py
    │   │   │   └── phone.py
    │   │   └── exceptions/
    │   │       ├── __init__.py
    │   │       ├── domain_exception.py
    │   │       └── business_rule_violation.py
    │   ├── infrastructure/
    │   │   ├── __init__.py
    │   │   ├── database/
    │   │   │   ├── __init__.py
    │   │   │   ├── base_repository.py
    │   │   │   └── unit_of_work.py
    │   │   ├── messaging/
    │   │   │   ├── __init__.py
    │   │   │   ├── event_bus.py
    │   │   │   └── message_broker.py
    │   │   └── utils/
    │   │       ├── __init__.py
    │   │       ├── id_generator.py
    │   │       └── datetime_utils.py
    │   └── application/
    │       ├── __init__.py
    │       ├── base_command.py
    │       ├── base_query.py
    │       └── base_application_service.py
    │
    ├── core_domains/                     # 核心域
    │   ├── __init__.py
    │   │
    │   ├── catalog/                      # 核心域1：商品目录域
    │   │   ├── __init__.py
    │   │   ├── bounded_contexts/
    │   │   │   ├── __init__.py
    │   │   │   │
    │   │   │   ├── product_management/   # 限界上下文1：商品管理
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── domain/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── aggregates/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── product/         # 聚合1：商品聚合
    │   │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   │   ├── product.py           # 聚合根
    │   │   │   │   │   │   │   ├── product_variant.py   # 实体
    │   │   │   │   │   │   │   ├── product_attribute.py # 值对象
    │   │   │   │   │   │   │   └── product_specification.py # 规约
    │   │   │   │   │   │   ├── category/        # 聚合2：分类聚合
    │   │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   │   ├── category.py          # 聚合根
    │   │   │   │   │   │   │   ├── category_hierarchy.py # 值对象
    │   │   │   │   │   │   │   └── category_rules.py    # 领域服务
    │   │   │   │   │   │   └── brand/           # 聚合3：品牌聚合
    │   │   │   │   │   │       ├── __init__.py
    │   │   │   │   │   │       ├── brand.py             # 聚合根
    │   │   │   │   │   │       ├── brand_authorization.py # 实体
    │   │   │   │   │   │       └── brand_policy.py      # 值对象
    │   │   │   │   │   ├── value_objects/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── product_id.py
    │   │   │   │   │   │   ├── sku.py
    │   │   │   │   │   │   ├── price.py
    │   │   │   │   │   │   └── weight.py
    │   │   │   │   │   ├── entities/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   └── product_review.py
    │   │   │   │   │   ├── domain_services/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── product_validation_service.py
    │   │   │   │   │   │   └── pricing_service.py
    │   │   │   │   │   ├── repositories/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── product_repository.py
    │   │   │   │   │   │   ├── category_repository.py
    │   │   │   │   │   │   └── brand_repository.py
    │   │   │   │   │   └── events/
    │   │   │   │   │       ├── __init__.py
    │   │   │   │   │       ├── product_created.py
    │   │   │   │   │       ├── product_updated.py
    │   │   │   │   │       └── product_discontinued.py
    │   │   │   │   ├── application/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── commands/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── create_product_command.py
    │   │   │   │   │   │   ├── update_product_command.py
    │   │   │   │   │   │   └── discontinue_product_command.py
    │   │   │   │   │   ├── queries/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── get_product_query.py
    │   │   │   │   │   │   └── search_products_query.py
    │   │   │   │   │   ├── handlers/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── product_command_handler.py
    │   │   │   │   │   │   └── product_query_handler.py
    │   │   │   │   │   └── services/
    │   │   │   │   │       ├── __init__.py
    │   │   │   │   │       └── product_application_service.py
    │   │   │   │   ├── infrastructure/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── persistence/
    │   │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   │   ├── sqlalchemy_product_repository.py
    │   │   │   │   │   │   ├── sqlalchemy_category_repository.py
    │   │   │   │   │   │   └── models/
    │   │   │   │   │   │       ├── __init__.py
    │   │   │   │   │   │       ├── product_model.py
    │   │   │   │   │   │       └── category_model.py
    │   │   │   │   │   └── external_services/
    │   │   │   │   │       ├── __init__.py
    │   │   │   │   │       └── image_service.py
    │   │   │   │   └── presentation/
    │   │   │   │       ├── __init__.py
    │   │   │   │       ├── api/
    │   │   │   │       │   ├── __init__.py
    │   │   │   │       │   ├── product_controller.py
    │   │   │   │       │   └── category_controller.py
    │   │   │   │       └── dto/
    │   │   │   │           ├── __init__.py
    │   │   │   │           ├── product_dto.py
    │   │   │   │           └── category_dto.py
    │   │   │   │
    │   │   │   └── inventory_management/     # 限界上下文2：库存管理
    │   │   │       ├── __init__.py
    │   │   │       ├── domain/
    │   │   │       │   ├── __init__.py
    │   │   │       │   ├── aggregates/
    │   │   │       │   │   ├── __init__.py
    │   │   │       │   │   └── inventory/
    │   │   │       │   │       ├── __init__.py
    │   │   │       │   │       ├── inventory.py
    │   │   │       │   │       ├── stock_movement.py
    │   │   │       │   │       └── reorder_policy.py
    │   │   │       │   └── repositories/
    │   │   │       │       ├── __init__.py
    │   │   │       │       └── inventory_repository.py
    │   │   │       ├── application/
    │   │   │       └── infrastructure/
    │   │   └── shared/                   # 该域内共享
    │   │       ├── __init__.py
    │   │       └── catalog_shared_types.py
    │   │
    │   └── trading/                      # 核心域2：交易域
    │       ├── __init__.py
    │       ├── bounded_contexts/
    │       │   ├── __init__.py
    │       │   ├── order_management/     # 订单管理上下文
    │       │   │   ├── __init__.py
    │       │   │   ├── domain/
    │       │   │   │   ├── aggregates/
    │       │   │   │   │   ├── order/
    │       │   │   │   │   │   ├── order.py
    │       │   │   │   │   │   ├── order_item.py
    │       │   │   │   │   │   └── order_status.py
    │       │   │   │   │   └── shopping_cart/
    │       │   │   │   │       ├── cart.py
    │       │   │   │   │       └── cart_item.py
    │       │   │   │   └── repositories/
    │       │   │   │       └── order_repository.py
    │       │   │   ├── application/
    │       │   │   ├── infrastructure/
    │       │   │   └── presentation/
    │       │   └── payment_processing/   # 支付处理上下文
    │       │       ├── __init__.py
    │       │       ├── domain/
    │       │       ├── application/
    │       │       ├── infrastructure/
    │       │       └── presentation/
    │       └── shared/
    │           ├── __init__.py
    │           └── trading_shared_types.py
    │
    └── supporting_domains/               # 支撑域
        ├── __init__.py
        └── user_management/              # 支撑域：用户管理域
            ├── __init__.py
            ├── bounded_contexts/
            │   ├── __init__.py
            │   ├── authentication/       # 认证上下文
            │   │   ├── __init__.py
            │   │   ├── domain/
            │   │   │   ├── aggregates/
            │   │   │   │   └── user/
            │   │   │   │       ├── user.py
            │   │   │   │       ├── user_credential.py
            │   │   │   │       └── login_session.py
            │   │   │   └── repositories/
            │   │   │       └── user_repository.py
            │   │   ├── application/
            │   │   ├── infrastructure/
            │   │   └── presentation/
            │   └── profile_management/   # 用户档案管理上下文
            │       ├── __init__.py
            │       ├── domain/
            │       ├── application/
            │       ├── infrastructure/
            │       └── presentation/
            └── shared/
                ├── __init__.py
                └── user_shared_types.py
</code></pre>
<h2><a id="%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关键设计说明</h2>
<h3><a id="1%E5%9F%9F%E7%9A%84%E5%88%86%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 域的分层</h3>
<ul>
<li><strong>core_domains/</strong>: 核心域，企业的核心竞争力</li>
<li><strong>supporting_domains/</strong>: 支撑域，支持核心业务</li>
<li><strong>shared/</strong>: 共享内核，跨域共享的基础设施</li>
</ul>
<h3><a id="2%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%BD%93%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 限界上下文的体现</h3>
<p>在 <code>catalog</code> 核心域中：</p>
<ul>
<li><strong>product_management</strong>: 商品管理上下文</li>
<li><strong>inventory_management</strong>: 库存管理上下文</li>
</ul>
<p>每个上下文都有完整的分层架构。</p>
<h3><a id="3%E8%81%9A%E5%90%88%E7%9A%84%E7%BB%84%E7%BB%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 聚合的组织</h3>
<p>在 <code>product_management</code> 上下文的 <code>domain/aggregates/</code> 中：</p>
<ul>
<li><strong>product/</strong>: 商品聚合（包含商品、商品变体等）</li>
<li><strong>category/</strong>: 分类聚合（包含分类层次结构）</li>
<li><strong>brand/</strong>: 品牌聚合（包含品牌授权等）</li>
</ul>
<h3><a id="4%E5%AE%8C%E6%95%B4%E7%9A%84-ddd%E5%88%86%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 完整的DDD分层</h3>
<p>每个限界上下文都包含：</p>
<ul>
<li><strong>Domain Layer</strong>: 聚合、实体、值对象、领域服务</li>
<li><strong>Application Layer</strong>: 应用服务、命令/查询处理器</li>
<li><strong>Infrastructure Layer</strong>: 持久化、外部服务适配</li>
<li><strong>Presentation Layer</strong>: API控制器、DTO</li>
</ul>
<h3><a id="5%E4%BE%9D%E8%B5%96%E6%96%B9%E5%90%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. 依赖方向</h3>
<pre><code class="language-plain_text">Presentation → Application → Domain ← Infrastructure
</code></pre>
<p>依赖始终指向内层，符合洋葱架构原则。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[各种Branching Model，workflow的比较思路和推荐小团队使用的精简有效的workflow]]></title>
    <link href="https://blog.luckyowl.me/16143819545361.html"/>
    <updated>2021-02-26T15:25:54-08:00</updated>
    <id>https://blog.luckyowl.me/16143819545361.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%B8%80%E3%80%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E9%80%89%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、分支管理模型选型</h2>
<p>Branching Model在业界有多种规范，如：<a href="https://nvie.com/posts/a-successful-git-branching-model/">Gitflow</a>、AoneFlow、<a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow">OneFlow</a>等，Branching Model的复杂程度取决于实际开发团队和代码规模，自动化程度等因素，实际使用时需要结合当前具体情况精简。但随着情况变化，当前的Model可能会不适用，需要定期Review并优化模型选型。</p>
<h2><a id="%E4%BA%8C%E3%80%81branching-model%E7%9A%84%E9%80%89%E5%9E%8B%E4%BE%9D%E6%8D%AE%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、Branching Model的选型依据参考</h2>
<ol>
<li>是否一个Repository同时有多人在分别开发不同feature，或者做bugfix，且需要同时deploy到不同环境。eg. dev, pre, production, grayscale etc.
<ul>
<li>解决方案：每个环境需要一个对应的branch或tag</li>
</ul>
</li>
<li>是否需要同时维护多个长期版本
<ul>
<li>解决方案：需要多个base branch</li>
</ul>
</li>
<li>是否需要一个branch来记录latest stable version，这个version和production environment上deploy的内容完全一致
<ul>
<li>解决方案：需要一个mark branch</li>
</ul>
</li>
<li>是否需要在发布新版本到生产环境前冻结代码进行控制
<ul>
<li>解决方案：需要对应一个branch，此branch开发无权限merge，代码被merge到此branch之后开始做集成测试</li>
</ul>
</li>
<li>是否有CI/CD自动化工具
<ul>
<li>解决方案：CI/CD自动化工具可以简化开发对git的操作</li>
</ul>
</li>
</ol>
<h2><a id="%E4%B8%89%E3%80%81%E5%B0%8F%E5%9E%8B%E5%9B%A2%E9%98%9F%E9%80%89%E5%9E%8B%E7%BB%93%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、小型团队选型结论</h2>
<ol>
<li>存在多个开发在一个Repository上开发不同feature然后合并到一起测试和同时deploy到production environment的场景</li>
<li>不需要维护多个长期版本</li>
<li>不需要一个单端的branch来记录production environment上deploy的内容</li>
<li>不必要deploy前冻结代码</li>
<li>无CI/CD自动化工具</li>
</ol>
<h3><a id="%E7%BB%93%E8%AE%BA%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结论：</h3>
<p>用到的branch（尽量少）：</p>
<ul>
<li>develop branch</li>
<li>release branch</li>
<li>feature branch</li>
</ul>
<h2><a id="%E5%9B%9B%E3%80%81branching-model-workflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、branching model &amp; workflow</h2>
<ul>
<li>使用long live的develop branch来记录最新的代码</li>
<li>使用short live的release branch来记录next version的代码，并且使用release branch部署test和production environment</li>
<li>使用Tag来记录latest的production environment内容</li>
<li>在最新的Tag上创建short live的bugfix branch用来修production environment的bug</li>
</ul>
<p>具体的workflow如下：</p>
<h3><a id="4-1-working-on-a-feature-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 working on a feature branch</h3>
<ol>
<li>Fetch develop branch so as to make it up to date</li>
</ol>
<pre><code class="language-plain_text">$ git fetch develop
</code></pre>
<ol start="2">
<li>Start a new feature branch</li>
</ol>
<pre><code class="language-plain_text">$ git checkout -b feature/${customized_feature_name} origin/develop
</code></pre>
<ol start="3">
<li>Implement feature and commit several times</li>
</ol>
<pre><code class="language-plain_text">$ git commit -a --amend
</code></pre>
<ol start="4">
<li>Merge with latest develop branch</li>
</ol>
<pre><code class="language-plain_text">$ git fetch develop
$ git rebase origin/develop
</code></pre>
<ol start="5">
<li>Self-testing</li>
<li>Push your branch. Make sure you have only one commit for your feature before push</li>
</ol>
<pre><code class="language-plain_text">$ git log
$ git rebase -i hash
$ git push origin feature/${customized_feature_name}
</code></pre>
<ol start="7">
<li>Open your browser and visit the &quot;pull request url&quot; printed on your console, then finish committing a PR on your browser with detailed test cases in your comment.</li>
</ol>
<h3><a id="4-2-working-on-a-release-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 working on a release branch</h3>
<p>You need a release branch when you decide to deploy a new release to production environment.</p>
<ol>
<li>Fetch develop branch so as to make it up to date</li>
</ol>
<pre><code class="language-plain_text">$ git fetch develop
</code></pre>
<ol start="2">
<li>Start a release branch</li>
</ol>
<pre><code class="language-plain_text">$ git log origin/develop
$ git checkout -b release/x.y.z hash
</code></pre>
<ol start="3">
<li>Deploy to test environment based on release/x.y.z branch</li>
<li>Test thoroughly &amp; Bug fixing(There should be only one commit for all bugs)</li>
<li>Deploy to production environment based on release/x.y.z branch's latest commit &amp; Test</li>
<li>Squash commits &amp; Tag the commit</li>
</ol>
<pre><code class="language-plain_text">$ git rebase -i hash
$ git tag x.y.z
</code></pre>
<ol start="7">
<li>Merge to develop branch and push</li>
</ol>
<pre><code class="language-plain_text">$ git checkout develop
$ git pull origin develop
$ git merge release/x.y.z
$ git push --tags origin develop
$ git branch -d release/x.y.z
</code></pre>
<h3><a id="4-3-working-on-a-hotfix-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 working on a hotfix branch</h3>
<ol>
<li>Start a bugfix branch</li>
</ol>
<pre><code class="language-plain_text">$ git checkout -b hotfix/x.y.1 x.y.0
</code></pre>
<ol>
<li>Code and fix bugs</li>
<li>Finish a bugfix branch</li>
</ol>
<pre><code class="language-plain_text">$ git checkout develop
$ git pull origin develop
$ git merge hotfix/x.y.1
$ git push --tags origin develop
$ git branch -d hotfix/x.y.1
</code></pre>
<p>rebase -i用法参考</p>
<blockquote>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">Rewriting History Chapter from Pro Git SCM book</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DDD学习笔记]]></title>
    <link href="https://blog.luckyowl.me/15771545679019.html"/>
    <updated>2019-12-23T18:29:27-08:00</updated>
    <id>https://blog.luckyowl.me/15771545679019.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是领域驱动</h2>
<h3><a id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据模型驱动</h3>
<p>传统服务建模的过程是先通过业务分析数据模型，然后在关系型数据库上基于范式设计数据库表以及表之间的关系。最后通过ORM建立起数据持久化对象和数据库表之间的映射。还要通过数据访问对象(DAO)来操作数据持久化对象。</p>
<p>由于持久化对象和数据访问对象都不包含业务逻辑，服务就成为了业务逻辑的唯一栖身之地。这时，持久化对象是数据的提供者，实现服务时就会非常自然地选择事务脚本（Transaction Script）模式。</p>
<p>《企业应用架构模式》对事务脚本的定义为：</p>
<blockquote>
<p>使用过程来组织业务逻辑，每个过程处理来自表现层的单个请求。这是一种典型的过程式设计，每个服务功能都是一系列步骤的组合，从而形成一个完整的事务。注意，这里的事务代表一个完整的业务行为过程，而非保证数据一致性的事务概念。</p>
</blockquote>
<p>不要因为事务脚本采用面向过程设计就排斥这一模式，相较于对编程范式的偏执，我认为 Martin Fowler 在书中说的一句话更加公道：</p>
<blockquote>
<p>“不管你是多么坚定的面向对象的信徒，也不要盲目排斥事务脚本。许多问题本身是简单的，一个简单的解决方案可以加快你的开发速度，而且运行起来也会更快。”</p>
</blockquote>
<p>即使采用事务脚本，我们也可以通过提取方法来改进代码的可读性。每个方法都提供了一定的抽象层次，通过方法的提取就可以在一定程度上隐藏细节，保持合理的抽象层次。这种方式被 Kent Beck 总结为组合方法（Composed Method）模式：</p>
<ul>
<li>把程序划分为方法，每个方法执行一个可识别的任务</li>
<li>让一个方法中的所有操作处于相同的抽象层</li>
<li>这会自然地产生包含许多小方法的程序，每个方法只包含少量代码</li>
</ul>
<h3><a id="%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域建模驱动</h3>
<p>领域建模驱动是相对于数据建模驱动的。<br />
领域建模驱动要先识别出领域，确定领域模型，然后再确定技术实现方案。<br />
识别领域确定领域模型的过程需要分析清楚问题域，理清业务。所以领域驱动设计倡导的是从问题出发，先分析问题域得到业务，然后结合业务、规模、系统结构进行设计，然后再编码实现。</p>
<ul>
<li>问题域——客户的需求</li>
<li>解决方案域——需求的实现</li>
</ul>
<pre><code class="language-plain_text">问题-&gt;领域-&gt;业务逻辑-&gt;规模-&gt;结构-&gt;实现
</code></pre>
<h2><a id="ddd%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AA%81%E7%84%B6%E7%81%AB%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD为什么突然火了</h2>
<p>微服务的划分粒度如何把握。</p>
<blockquote>
<p>纵观软件设计的历史，不是分久必合、合久必分，而是不断拆分、持续拆分的微型化过程。</p>
</blockquote>
<p>限界上下文(Bounded Context)有利于确定微服务的划分。</p>
<p>理论上：</p>
<ul>
<li>一个微服务不要小于一个聚合</li>
<li>一个微服务不要大于一个限界上下文</li>
</ul>
<p>如果出现如下情况说明微服务划分不合理：</p>
<ul>
<li>微服务间经常需要分布式事务来支持业务数据一致性</li>
<li>对于微服务A来说，处理一个请求总是依赖另一个微服务B</li>
<li>一个微服务中出现多个名字相同的领域实体</li>
</ul>
<h2><a id="ddd%E7%9A%84%E4%BB%B7%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的价值</h2>
<blockquote>
<p>应对软件复杂度</p>
</blockquote>
<ul>
<li>从领域出发，保证软件分析模型和设计模型一致，业务人员和开发协作，保证软件质量</li>
<li>提出统一语言，确保所有概念在各自的上下文中清晰无歧义</li>
<li>提出分层架构，有效分离业务和技术，同时从垂直方向上做分隔职责边界</li>
<li>战略设计通过拆分子域和限界上下文，从横向上分隔离职责边界</li>
<li>战术设计通过引入多种领域模型概念帮助领域模型设计落地</li>
<li>引入微服务间协作的设计模式</li>
</ul>
<h3><a id="%E8%BD%AF%E4%BB%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%8D%E6%9D%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>软件为什么会复杂</h3>
<p>主观可控：</p>
<ul>
<li>业务规则 <em>复杂</em></li>
<li>需求变化 <em>不可预测</em></li>
<li>规模变 <em>大</em></li>
<li>结构变 <em>复杂</em></li>
<li>技术选型 <em>升级</em></li>
</ul>
<p>主观不可控：</p>
<ul>
<li>人不够</li>
<li>人员流动</li>
<li>时间紧</li>
<li>组织架构不合理</li>
</ul>
<h3><a id="%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何应对软件复杂</h3>
<p><strong>关注点分离（Separation of Concern）</strong></p>
<ul>
<li>分离业务和技术
<ul>
<li>分层架构
<ul>
<li>六边形架构</li>
<li>整洁架构</li>
</ul>
</li>
<li>分层
<ul>
<li>UI层（User Interface Layer）</li>
<li>应用层（Application Layer）</li>
<li>领域层（Domain Layer）</li>
<li>技术设施层（Infrastructure Layer）</li>
</ul>
</li>
<li>设计原则
<ul>
<li>SRP (Single-Responsibility Principle)</li>
<li>DIP (Dependency inversion principle)</li>
<li>Interface-Oriented Programming</li>
<li>Dependency Injection</li>
</ul>
</li>
</ul>
</li>
<li>分离职责
<ul>
<li>限界上下文</li>
<li>聚合</li>
<li>领域</li>
</ul>
</li>
</ul>
<p><img src="media/15771545679019/15771737688932.jpg" alt="" /></p>
<p><img src="media/15771545679019/15771749354517.jpg" alt="" /></p>
<h2><a id="ddd%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的设计过程</h2>
<p><img src="media/15771545679019/15771554676189.jpg" alt="" /></p>
<h3><a id="%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战略设计阶段</h3>
<ul>
<li>问题域
<ul>
<li>限界上下文（Bounded Context）</li>
<li>上下文映射（Context Map）</li>
<li>核心域（Core Domain）</li>
<li>子域（Subdomain）</li>
</ul>
</li>
<li>架构
<ul>
<li>六边形架构</li>
<li>整洁架构</li>
<li>CQRS</li>
<li>Event Sourcing</li>
</ul>
</li>
</ul>
<h3><a id="%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战术设计阶段</h3>
<ul>
<li>值对象（Value Object）</li>
<li>实体（Entity）</li>
<li>领域服务（Domain Service）</li>
<li>领域事件（Domain Event）</li>
<li>资源库（Repository）</li>
<li>工厂（Factory）</li>
<li>聚合（Aggregate）</li>
<li>应用服务（Application Service）</li>
</ul>
<p><img src="media/15771545679019/15771569102713.jpg" alt="" /></p>
<h3><a id="%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个完整的生命周期</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>参与者</th>
<th>产出物</th>
</tr>
</thead>
<tbody>
<tr>
<td>需求</td>
<td>产品经理、客户</td>
<td>需求文档</td>
</tr>
<tr>
<td>KickOff</td>
<td>产品经理、客户、开发负责人、测试负责人</td>
<td>明确利益相关人、对业务的共同理解、识别主要用户故事</td>
</tr>
<tr>
<td>事件风暴</td>
<td>领域专家、产品经理、DDD专家、架构师、相关开发</td>
<td>统一语言、领域模型</td>
</tr>
<tr>
<td>架构设计</td>
<td>架构师、DDD专家</td>
<td>代码包结构、技术选型、系统间通信方式</td>
</tr>
<tr>
<td>开发</td>
<td>架构师、开发</td>
<td>单元测试、代码实现</td>
</tr>
<tr>
<td>演示</td>
<td>产品经理、开发负责人、测试负责人、领域专家、客户</td>
<td>客服意见</td>
</tr>
<tr>
<td>测试</td>
<td>测试</td>
<td>测试报告</td>
</tr>
<tr>
<td>交付</td>
<td>运维、开发、测试</td>
<td>服务</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8F%90%E7%82%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域模型的提炼</h2>
<p><img src="media/15771545679019/15776877632436.jpg" alt="" /></p>
<h3><a id="6w%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6W模型</h3>
<ul>
<li>Who: 角色，一个场景中参与的用户是什么角色</li>
<li>Why: 价值，解决用户什么问题</li>
<li>What: 功能，需要做什么</li>
<li>When: 流程，具体的业务逻辑是什么</li>
<li>Where: 边界，场景的边界</li>
<li>How: 实现，具体的技术实现</li>
</ul>
<h3><a id="%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD6w%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何实施6W模型</h3>
<h4><a id="1%E7%94%A8%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 用例</h4>
<pre><code class="language-plain_text">用例名称：批量增加主机
用例目的（Why）：本用例可以帮助「角色（Who）」为其微服务一次性关联（What）符合「条件」的主机
参与者（Who）：「角色」
前置条件：微服务已经被纳管

基础流程（When）：
1. ……
2. ……
3. ……

替代流程：异常情况一
替代流程：异常情况二
</code></pre>
<h4><a id="2-tdd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. TDD</h4>
<pre><code class="language-java">@Autowared
private HostAppService hostAppService;

@Test
// 测试方法以描述业务的形式命名
// 不要对被测试方法写单元测试，要对领域场景编写，驱动我们识别场景分解任务
public void should_return_100_when_100_valid_hosts_registered_successfully() {
    // given 驱动我们思考对象的创建，与其他对象的协作，领域对象的命名（统一语言）
    Microservice microservice = Mock.one(Microservice.class);
    List&lt;Host&gt; validHosts = validHosts(100);
    
    // when 驱动我们思考职责边界、方法的命名、入参
    int successAmount = hostAppService.registerHostsForMicroservice(microservice, validHosts)
}
    
    // then 驱动我们思考方法的返回值、对系统的其他影响
    AssertThat(successAmount, is(100));
</code></pre>
<h2><a id="%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>统一语言</h2>
<ul>
<li>通过事件风暴获得统一语言的中文</li>
<li>标注对应英文</li>
<li>引入局外人对用例的阐述进行提问</li>
<li>统一语言要具备专业性（水，H2O）</li>
</ul>
<h2><a id="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限界上下文</h2>
<p>限界上下文需要满足四个特征：</p>
<ul>
<li>最小完备：要完备，而且要最小；不依赖外部</li>
<li>自我履行：知识专家，基于掌握的知识决定需要履行的职责，不做边界外的职责</li>
<li>稳定空间：分离内外，外部变化对内不影响</li>
<li>独立进化：自身进化对外不影响</li>
</ul>
<h3><a id="%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>识别限界上下文</h3>
<p>识别限界上下文就是寻找边界：基于业务边界、技术边界，找到限界上下文的边界，进而找到工作边界、应用边界。</p>
<p><img src="media/15771545679019/15785351896389.jpg" alt="" /></p>
<h3><a id="%E9%AA%8C%E8%AF%81%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>验证识别结果</h3>
<ul>
<li>是否能给限界上下文轻松的命名</li>
<li>限界上下文之间是否容易协作</li>
</ul>
<h3><a id="%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上下文协作关系</h3>
<p><img src="media/15771545679019/15794115154549.jpg" alt="" /></p>
<p>上下文映射模式：</p>
<ol>
<li>合作关系（Partnership）</li>
<li>共享内核（Shared Kernel）</li>
<li>客户方-供应方开发（Customer-Supplier Development）</li>
<li>遵奉者（Conformist）</li>
<li>分离方式（Separate Ways）</li>
</ol>
<p>降低上下文之间耦合的模式：</p>
<ol>
<li>防腐层（Anticorruption Layer）</li>
<li>开放主机服务（Open Host Service）</li>
<li>发布/订阅事件</li>
</ol>
<p>附：《实现领域驱动设计》里的9种组织模式和集成模式</p>
<pre><code class="language-plain_text">①合作关系（Partnership）

如果2个限界上下文的团队要么一起成功，要么一起失败，此时就是这种关系。应该为相互关联的软件功能制定好计划表，这样可以确保这些功能在同一个发布中完成。

②共享内核（Shared Kernel）
   
对模型和代码的共享将产生一种紧密的依赖性，对于设计来说，这种依赖性可好可坏。我们需要为共享的部分模型指定一个显式边界，并保持共享内核的小型化。共享内核具有特殊的状态，在没有与另一个团队协商的情况下，这种状态是不能改变的。我们应该引入一种持续集成过程来保证共享内核与通用语言的一致性。

③客户方——供应方（Customer-Supplier Development）

当2个团队处于一种上游——下游关系时，上游团队可能独立于下游团队完成开发，此时下游团队的开发可能会受到很大的影响。因此，在上游团队的计划中，我们应该顾及到下游团队的需求。

④遵奉者（Conformist）

在存在上游——下游关系的2个团队中，如果上游团队已经没有动力提供下游团队之需，下游团队便孤军无助了。处于利他主义，上游团队可能向下游团队做出种种承诺，但是有很大的可能是：这些承诺是无法实现的。下游团队只能盲目地使用上游团队模型。

⑤防腐层（Anticorruption Layer）

在集成2个设计良好的限界上下文时，翻译层可能很简单，甚至可以很优雅的实现。但是，当共享内核，合作关系或客户方——供应方关系无法顺利实现时，此时的翻译将变得复杂。对于下游客户来说，你需要根据自己的领域模型创建一个单独的层，该层作为上游系统的委派向你的系统提供功能。防腐层通过已有的接口与其他系统交互，而其他系统只需要做很小的修改，甚至无需修改。在防腐层内部，它在你自己的模型和他方模型之间进行翻译转换。【为每个防腐层定义相应的领域服务】

⑥开放主机服务（Open Host Service）

定义一种协议，让你的子系统通过该协议来访问你的服务。并且需要将协议公开。

⑦发布语言（Published Language）

在2个限界上下文之间翻译模型需要一种公用的语言。此时你应该使用一种发布出来的共享语言来完成集成交流。发布语言通常与开放主机服务一起使用。

⑧另谋他路（SeparateWay）

在确定需求时，我们应该做到坚持彻底。如果2套功能没有显著的关系，那么它们是可以被完全解耦的。集成总是昂贵的，有时带给你的好处也不大。声明2个限界上下文之间不存在任何关系，这样使得开发者去另外寻找简单的、专门的方法来解决问题。

⑨大泥球（Big Ball of Mud）

当我们检查已有系统时，经常会发现系统中存在混杂在一起的模型，它们之间的边界是非常模糊的。此时你应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。在这个边界内，不要试图使用复杂的建模手段来化解问题。同时，这样的系统有可能会向其他系统蔓延，应该对此保持警觉。
</code></pre>
<h3><a id="%E5%88%92%E5%88%86%E5%9B%A2%E9%98%9F%E5%92%8C%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>划分团队和应用</h3>
<ul>
<li>基于语义相关性和功能相关性识别出限界上下文</li>
<li>基于<code>2PTs规则</code>、<code>特性团队</code>、<code>康威定律</code>思想划分团队，找到工作边界</li>
<li>基于<code>重用性</code>、<code>业务变化</code>、<code>质量属性</code>、<code>技术选型</code>等技术考虑划分应用边界，并持续重构</li>
</ul>
<h2><a id="%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E4%BA%A7%E5%87%BA%E7%89%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战略设计阶段产出物</h2>
<ol>
<li>利益相关人</li>
<li>业务期望和愿景</li>
<li>项目业务范围</li>
<li>业务流程</li>
<li>史诗级故事和主故事</li>
<li>根据核心参与者识别用例，输出每个参与者的用例图</li>
<li>根据语义相关性和功能相关性识别出用例主题边界，输出用例主题</li>
<li>根据主题之间的相关性识别限界上下文</li>
<li>上下文映射图或表</li>
<li>输出架构4+1视图
<ol>
<li>逻辑视图：限界上下文图；上下文映射图；分层架构</li>
<li>进程视图：限界上下文图；六边形架构；上下文映射</li>
<li>物理视图：六边形架构</li>
<li>开发视图：分层架构；代码模型</li>
<li>场景视图：领域场景分析；用例图</li>
</ol>
</li>
</ol>
<h3><a id="%E6%9E%B6%E6%9E%844-1%E8%A7%86%E5%9B%BE%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>架构4+1视图举例</h3>
<h4><a id="1%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 逻辑视图</h4>
<p><img src="media/15771545679019/15833010184246.jpg" alt="" /></p>
<p>视图说明</p>
<ul>
<li>系统层次的分层架构</li>
<li>限界上下文层次的分层架构</li>
</ul>
<h4><a id="2%E8%BF%9B%E7%A8%8B%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 进程视图</h4>
<p><img src="media/15771545679019/15833010852284.jpg" alt="" /></p>
<p>视图说明</p>
<ul>
<li>在绘制系统的进程视图时，不需要将每个牵涉到进程间调用的用例场景都展现出来，而是将这些参与协作的组件以抽象方式表达一个典型的全场景即可。</li>
<li>整个进程视图非常清晰地表达了部署在不同进程之上的组件或子系统之间的协作关系，同时通过图例体现了领域驱动设计中的北向网关和南向网关与外部资源之间的协作。调用的方式是同步还是异步，也一目了然。</li>
</ul>
<h4><a id="3%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 物理视图</h4>
<p><img src="media/15771545679019/15833011711307.jpg" alt="" /></p>
<p>物理视图与进程视图虽然都以进程边界为主要的设计单元，但二者的关注点不同。进程视图是动态的，体现的是外部环境、系统各个组件在进程之间的协作方式与通信机制；物理视图是静态的，主要体现系统各个模块以及系统外部环境的部署位置与部署方式。</p>
<h4><a id="4%E5%BC%80%E5%8F%91%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 开发视图</h4>
<p><img src="media/15771545679019/15833012202839.jpg" alt="" /></p>
<ul>
<li>给出代码分层结构</li>
<li>分别体现出系统级代码分层结构和限界上下文内的代码分层结构</li>
</ul>
<h2><a id="%E5%AE%9E%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实体</h2>
<h2><a id="%E5%80%BC%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>值对象</h2>
<h2><a id="%E8%81%9A%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合</h2>
<p>引入聚合来划分对象之间的边界，保证边界内所有对象的一致性。其中作为主体的实体对象是聚合根。</p>
<h3><a id="%E8%81%9A%E5%90%88%E8%BE%B9%E7%95%8C%E7%9A%84%E8%AF%86%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合边界的识别</h3>
<ul>
<li>是否多实体同生命周期，同生同死组合关系（完整性）</li>
<li>是否单实体有独立性需求，外界需要直接和他交互（独立性）</li>
<li>是否存在不变量</li>
<li>是否处于一个事务中</li>
</ul>
<h3><a id="%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则</h3>
<ul>
<li>外界只能和聚合根交互</li>
<li>聚合根可以向外部传递内部实体的引用，但外部对象只能临时使用</li>
<li>聚合根可以向外部传递值对象的副本</li>
<li>只有聚合根才能直接通过数据库获得，其他实体通过聚合根获得</li>
</ul>
<h2><a id="%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域服务</h2>
<p>存在跨聚合的业务场景时需要使用领域服务</p>
<h2><a id="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分层架构</h2>
<p>传统三层架构和领域驱动经典四层架构的对比：</p>
<p><img src="media/15771545679019/15802181588889.jpg" alt="" /><br />
经典三层架构</p>
<p><img src="media/15771545679019/15802181811457.jpg" alt="" /><br />
Eric Evans 在其经典著作《领域驱动设计》中的四层架构</p>
<ul>
<li>领域驱动四层架构多引入了<code>Application Layer</code></li>
<li><code>业务逻辑层</code>改名为<code>Domain Layer</code>，定位更具体</li>
<li><code>数据访问层</code>的名字变为<code>Infrastructure Layer</code>，职责扩大</li>
</ul>
<h3><a id="%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对比分析</h3>
<p>优化后的分层架构通过引入<code>Application Layer</code>，使<code>Domain Layer</code>可以专注业务逻辑，不依赖外部环境，更内聚。<br />
<code>Infrastructure Layer</code>用来分离业务和技术关注点，并不只用来请求数据。</p>
<h3><a id="%E4%BC%A0%E7%BB%9F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7%E5%88%B0ddd%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统三层架构升级到DDD四层架构</h3>
<p><img src="media/15771545679019/15802218910157.jpg" alt="" /><br />
三层架构代码模型</p>
<p><img src="media/15771545679019/15802220571963.jpg" alt="" /><br />
把Java Beans变成充血模型的POJO，并迁移到业务逻辑层。此时POJO对应DDD的Entity和Value Object，业务逻辑层变为领域层。此时领域层和基础设施层相互依赖。</p>
<p><img src="media/15771545679019/15802221495986.jpg" alt="" /><br />
通过依赖反转和依赖注入解耦领域层到基础设施层的依赖。但多了一层基础设施的抽象层。</p>
<p><img src="media/15771545679019/15802223804941.jpg" alt="" /><br />
通过DDD的Repository概念，使基础设施抽象层进入领域层。此时用户展现层仍然直接依赖领域层，领域层对外暴露太多细节。</p>
<p><img src="media/15771545679019/15802224971320.jpg" alt="" /><br />
通过引入开放主机服务，隔离开前端对领域层的直接依赖。但此时通过Controller暴露出去的服务仍然过细。</p>
<p><img src="media/15771545679019/15802226450442.jpg" alt="" /><br />
引入应用层，封装如批量查询、请求跳转、跨领域聚合的业务编排等逻辑。通过Facade模式提供高层接口。到此迁移完毕。</p>
<h3><a id="%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整洁架构</h3>
<p><img src="media/15771545679019/15802197310420.jpg" alt="" /><br />
Robert Martin 提出的整洁架构</p>
<ul>
<li>层次越靠内的组件依赖的内容越少，处于核心的 Entities 没有任何依赖。</li>
<li>层次越靠内的组件与业务的关系越紧密，因而越不可能形成通用的框架。</li>
<li>Entities 层封装了企业业务规则，准确地讲，它应该是一个面向业务的领域模型。</li>
<li>Use Cases 层是打通内部业务与外部资源的一个通道，因而提供了输出端口（Output Port）与输入端口（Input Port），但它对外的接口展现的其实是应用逻辑，或者说是一个用例。</li>
<li>Gateways、Controllers 与 Presenters 其本质都是适配器（Adapter），用于打通应用业务逻辑与外层的框架和驱动器，实现逻辑的适配以访问外部资源。</li>
<li>系统最外层包括框架和驱动器，负责对接外部资源，不属于系统（仅指限界上下文而言）开发的范畴，但选择这些框架和驱动器，是属于设计决策要考虑的内容。这一层的一些组件甚至与要设计的系统不处于同一个进程边界。</li>
</ul>
<h3><a id="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微服务架构</h3>
<p><img src="media/15771545679019/15802207740226.jpg" alt="" /><br />
Martin Fowler的微服务架构</p>
<p>整幅图的架构其实蕴含了两个方向：自顶向下和由内至外。</p>
<ul>
<li>外部请求通过代表协议（Protocol）的 Resources 组件调用 Service Layer、Domain 或 Repositories，如果需要执行持久化任务，则通过 Repositories 将请求委派给 ORM，进而访问网络边界外的数据库。所谓“外部请求”可以是前端 UI 或第三方服务，而 Resource 组件就是我们通常定义的 Controller，对应于上下文映射中的开放主机服务。之所以命名为 Resources，则是因为 REST 架构是一种面向资源的架构，它将服务操作的模型抽象为资源（Resource），这是自顶向下的方向。</li>
<li>若当前微服务需要调用外部服务（External Service），且外部服务籍由 HTTP 协议通信，就需要提供一个 HTTP Client 组件完成对外部服务的调用。为了避免当前微服务对外部服务的强依赖，又或者对客户端的强依赖，需要引入 Gateways 来隔离。事实上，这里的 Gateways 即为上下文映射中的防腐层，这是由内至外的方向。</li>
</ul>
<h2><a id="ddd%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的代码模型</h2>
<p>以电商下单业务为例：</p>
<p><img src="media/15771545679019/15803904268910.jpg" alt="" /></p>
<p>代码结构如下所示：</p>
<pre><code class="language-plain_text">ordercontext.infrastructure
    - OrderController
    - OrderMapper
    - EmailSender
    - RabbitEventBus
ordercontext.application
    - OrderAppService
    - NotificationService
    - EventBus
ordercontext.domain
    - OrderRepository
    - PlaceOrderService
    - Order
    - Notification
    - OrderConfirmed
    - NotificationComposer
    - OrderConfirmedComposer
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人类能否造出真正智能的机器人？]]></title>
    <link href="https://blog.luckyowl.me/15763252898733.html"/>
    <updated>2019-12-14T04:08:09-08:00</updated>
    <id>https://blog.luckyowl.me/15763252898733.html</id>
    <content type="html"><![CDATA[
<p>机器人是什么？<br />
是计算机。<br />
计算机是什么？<br />
冯诺依曼结构的计算机可以抽象为“输入”、“计算”和“输出”三部分。<br />
计算机的智能体现在其扩展能力上。<br />
其输入从最早的打孔纸带扩展到现在的键盘，鼠标、语音，传感器等。<br />
其计算能力可以通过编程来扩展。<br />
其输出从最初的显示器扩展到现在的扬声器、打印机、投影仪等。<br />
机器人的智能体现在，对于不同输入都可以给出“智能”的输出。这个“智能”体现在其处理逻辑会随着处理其他输入而自动升级。表现出会学习的特征。<br />
何为非真正智能的机器人？<br />
不会主动“思考”、“学习”的机器人就不是真正智能的机器人。<br />
如果机器人能够主动的“思考”、“学习”了之后，他和人类有什么区别？<br />
他应该从能力上超过人类。<br />
为了想清楚机器人是否可能最终成为真正“智能”的机器人，我们需要把机器人和人类做一下对比。<br />
然而我认为人类其实也是遵循冯诺依曼结构工作的！<br />
人类刚出生时对于绝大多数输入是没有反应的，即还不具备对输入的计算能力。<br />
随着被动学习，对于固定输入的计算逻辑建立起来了。此时开始模仿，即对于给定的输入，其计算逻辑始终不变，只是越算越快，这是一个熟练过程。<br />
然而人类刚出生也不是对所有输入都没有计算能力的，比如对于疼痛的计算，对于饥饿的计算，对于光线的计算……<br />
随着年龄长大，逐渐体现出对于一些输入会输出嫉妒、气愤、喜欢……<br />
这些其实是人类的基因决定的。<br />
那基因是什么？<br />
其实就是随着人类从远古到现代的进化中积累下来的计算逻辑。比如，人类有攀比心，其实是对于比自己好这个输入的计算，其输出是我要超过他的激素刺激。<br />
正是因为人类天生具备七宗罪的天性基因，才让人类得以主动思考，主动学习。<br />
所以，如果可以破解人类基因，并且给机器人输入这些基因程序，则机器人就可以和人类一样智能。在不给机器人任何输入的情况下，机器人也会基于这个“没有任何输入”的信号，并结合之前的记忆去计算然后表现出机器人在“思考”……</p>

]]></content>
  </entry>
  
</feed>
