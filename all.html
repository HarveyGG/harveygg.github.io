<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Harvey's Tech Site
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Harvey's Tech Site" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site: ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="mac-dev-env.html">MAC开发环境</a></li>
        
        <li id=""><a target="_self" href="internet-tech.html">互联网技术</a></li>
        
        <li id=""><a target="_self" href="architecture-designing.html">架构设计</a></li>
        
        <li id=""><a target="_self" href="middleware.html">中间件</a></li>
        
        <li id=""><a target="_self" href="dev-ops">DevOps</a></li>
        
        <li id=""><a target="_self" href="java.html">Java</a></li>
        
        <li id=""><a target="_self" href="yi.html">易经</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Harvey's Tech Site</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="mac-dev-env.html">MAC开发环境</a></li>
        
        <li><a target="_self" href="internet-tech.html">互联网技术</a></li>
        
        <li><a target="_self" href="architecture-designing.html">架构设计</a></li>
        
        <li><a target="_self" href="middleware.html">中间件</a></li>
        
        <li><a target="_self" href="dev-ops">DevOps</a></li>
        
        <li><a target="_self" href="java.html">Java</a></li>
        
        <li><a target="_self" href="yi.html">易经</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="mac-dev-env.html">Mac开发环境</a></li>
        
            <li><a href="internet-tech.html">互联网技术</a></li>
        
            <li><a href="architecture-designing.html">架构设计</a></li>
        
            <li><a href="middleware.html">中间件</a></li>
        
            <li><a href="yi.html">易经</a></li>
        
            <li><a href="dev-ops.html">DevOps</a></li>
        
            <li><a href="java.html">Java</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16237800130779.html">
                
                  <h1>Linux运维常用命令组合</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h3><a id="lsof-i-port" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lsof -i:port</h3>
<p>根据监听端口号找进程PID</p>
<pre class="line-numbers"><code class="language-plain_text">COMMAND   PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME
node    14374 root   12u  IPv6 376449654      0t0  TCP *:8957 (LISTEN)
</code></pre>
<h3><a id="lsof-grep-deleted" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>lsof |grep deleted</h3>
<p>如果一个文件正在被一个运行中的进程读取，此时删除次文件，此文件空间不会被释放，使用du -sh无法统计此文件占用的空间；可以通过此命令查看已经被删除过仍然占用空间的文件清单，然后通过kill进程释放文件占用空间</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/6/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='dev-ops.html'>DevOps</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15616863130414.html">
                
                  <h1>MAC使用技巧</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；</li>
<li>finder下使用Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹；</li>
<li>恢复备份时的默认密码是：0000</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16143819545361.html">
                
                  <h1>各种Branching Model，workflow的比较思路和推荐小团队使用的精简有效的workflow</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E3%80%81%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E9%80%89%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、分支管理模型选型</h2>
<p>Branching Model在业界有多种规范，如：<a href="https://nvie.com/posts/a-successful-git-branching-model/">Gitflow</a>、AoneFlow、<a href="https://www.endoflineblog.com/oneflow-a-git-branching-model-and-workflow">OneFlow</a>等，Branching Model的复杂程度取决于实际开发团队和代码规模，自动化程度等因素，实际使用时需要结合当前具体情况精简。但随着情况变化，当前的Model可能会不适用，需要定期Review并优化模型选型。</p>
<h2><a id="%E4%BA%8C%E3%80%81branching-model%E7%9A%84%E9%80%89%E5%9E%8B%E4%BE%9D%E6%8D%AE%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、Branching Model的选型依据参考</h2>
<ol>
<li>是否一个Repository同时有多人在分别开发不同feature，或者做bugfix，且需要同时deploy到不同环境。eg. dev, pre, production, grayscale etc.
<ul>
<li>解决方案：每个环境需要一个对应的branch或tag</li>
</ul>
</li>
<li>是否需要同时维护多个长期版本
<ul>
<li>解决方案：需要多个base branch</li>
</ul>
</li>
<li>是否需要一个branch来记录latest stable version，这个version和production environment上deploy的内容完全一致
<ul>
<li>解决方案：需要一个mark branch</li>
</ul>
</li>
<li>是否需要在发布新版本到生产环境前冻结代码进行控制
<ul>
<li>解决方案：需要对应一个branch，此branch开发无权限merge，代码被merge到此branch之后开始做集成测试</li>
</ul>
</li>
<li>是否有CI/CD自动化工具
<ul>
<li>解决方案：CI/CD自动化工具可以简化开发对git的操作</li>
</ul>
</li>
</ol>
<h2><a id="%E4%B8%89%E3%80%81%E5%B0%8F%E5%9E%8B%E5%9B%A2%E9%98%9F%E9%80%89%E5%9E%8B%E7%BB%93%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、小型团队选型结论</h2>
<ol>
<li>存在多个开发在一个Repository上开发不同feature然后合并到一起测试和同时deploy到production environment的场景</li>
<li>不需要维护多个长期版本</li>
<li>不需要一个单端的branch来记录production environment上deploy的内容</li>
<li>不必要deploy前冻结代码</li>
<li>无CI/CD自动化工具</li>
</ol>
<h3><a id="%E7%BB%93%E8%AE%BA%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结论：</h3>
<p>用到的branch（尽量少）：</p>
<ul>
<li>develop branch</li>
<li>release branch</li>
<li>feature branch</li>
</ul>
<h2><a id="%E5%9B%9B%E3%80%81branching-model-workflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、branching model &amp; workflow</h2>
<ul>
<li>使用long live的develop branch来记录最新的代码</li>
<li>使用short live的release branch来记录next version的代码，并且使用release branch部署test和production environment</li>
<li>使用Tag来记录latest的production environment内容</li>
<li>在最新的Tag上创建short live的bugfix branch用来修production environment的bug</li>
</ul>
<p>具体的workflow如下：</p>
<h3><a id="4-1-working-on-a-feature-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 working on a feature branch</h3>
<ol>
<li>Fetch develop branch so as to make it up to date</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git fetch develop
</code></pre>
<ol start="2">
<li>Start a new feature branch</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git checkout -b feature/${customized_feature_name} origin/develop
</code></pre>
<ol start="3">
<li>Implement feature and commit several times</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git commit -a --amend
</code></pre>
<ol start="4">
<li>Merge with latest develop branch</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git fetch develop
$ git rebase origin/develop
</code></pre>
<ol start="5">
<li>Self-testing</li>
<li>Push your branch. Make sure you have only one commit for your feature before push</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git log
$ git rebase -i hash
$ git push origin feature/${customized_feature_name}
</code></pre>
<ol start="7">
<li>Open your browser and visit the &quot;pull request url&quot; printed on your console, then finish committing a PR on your browser with detailed test cases in your comment.</li>
</ol>
<h3><a id="4-2-working-on-a-release-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 working on a release branch</h3>
<p>You need a release branch when you decide to deploy a new release to production environment.</p>
<ol>
<li>Fetch develop branch so as to make it up to date</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git fetch develop
</code></pre>
<ol start="2">
<li>Start a release branch</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git log origin/develop
$ git checkout -b release/x.y.z hash
</code></pre>
<ol start="3">
<li>Deploy to test environment based on release/x.y.z branch</li>
<li>Test thoroughly &amp; Bug fixing(There should be only one commit for all bugs)</li>
<li>Deploy to production environment based on release/x.y.z branch's latest commit &amp; Test</li>
<li>Squash commits &amp; Tag the commit</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git rebase -i hash
$ git tag x.y.z
</code></pre>
<ol start="7">
<li>Merge to develop branch and push</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git checkout develop
$ git pull origin develop
$ git merge release/x.y.z
$ git push --tags origin develop
$ git branch -d release/x.y.z
</code></pre>
<h3><a id="4-3-working-on-a-hotfix-branch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 working on a hotfix branch</h3>
<ol>
<li>Start a bugfix branch</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git checkout -b hotfix/x.y.1 x.y.0
</code></pre>
<ol>
<li>Code and fix bugs</li>
<li>Finish a bugfix branch</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">$ git checkout develop
$ git pull origin develop
$ git merge hotfix/x.y.1
$ git push --tags origin develop
$ git branch -d hotfix/x.y.1
</code></pre>
<p>rebase -i用法参考</p>
<blockquote>
<p><a href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History">Rewriting History Chapter from Pro Git SCM book</a></p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/2/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='architecture-designing.html'>架构设计</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16129809371350.html">
                
                  <h1>(3) 我的MAC开发环境</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>iterm2<br />
brew<br />
yarn<br />
jenv<br />
nvm<br />
npm<br />
Intellij IDEA<br />
PyCharm<br />
GoLand<br />
Visual Studio Code<br />
Android Studio<br />
yarn global add react-devtools</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/2/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15961083014557.html">
                
                  <h1>vim实用高级命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>光标移动</h2>
<ul>
<li>下一个当前单词：*</li>
<li>上一个当前单词：#</li>
<li>下一个单词第一个字符：w</li>
<li>当前单词最后一个字符：e</li>
<li>下一个以空白字符为分隔的单词第一个字符：W</li>
<li>当前以空白字符为分隔的单词最后一个字符：E</li>
<li>前一个单词第一个字符：b</li>
<li>前一个以空白字符为分隔的单词第一个字符：B</li>
<li>下一个特定字符之前：t+字符 till</li>
<li>上一个特定字符之后：T+字符</li>
<li>下一个特定字符之上：f+字符 find</li>
<li>上一个特定字符之上：F+字符</li>
<li>当前行最后一个字符上：$</li>
<li>当前行最后一个非空字符上：g_</li>
<li>当前行第一个字符上：0</li>
<li>当前行第一个非空字符上：^</li>
<li>第一行：gg 或 :1</li>
<li>最后一行：G</li>
<li>第N行： :N</li>
<li>迅速移动到下一句开头：）</li>
<li>迅速移动到上一句开头：（</li>
<li>迅速移动到下一段开头：}</li>
<li>迅速移动到上一段开头：{</li>
</ul>
<h2><a id="%E6%BB%9A%E5%8A%A8%E5%B1%8F%E5%B9%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>滚动屏幕</h2>
<ul>
<li>向下翻页：<code>&lt;C+f&gt;</code> forward</li>
<li>向上翻页：<code>&lt;C+b&gt;</code> backward</li>
<li>向下翻半页：<code>&lt;C+d&gt;</code> down</li>
<li>向上翻半页：<code>&lt;C+u&gt;</code> up</li>
<li>光标不动，向下逐行滚动：<code>&lt;C+e&gt;</code> elder</li>
<li>光标不动，向上逐行滚动：<code>&lt;C+y&gt;</code> younger</li>
<li>光标不动，使光标所在行翻到屏幕最上方：zt title</li>
<li>光标不动，使光标所在行翻到屏幕最下方：zb bottom</li>
<li>光标不动，使光标所在行翻到屏幕中间：zz</li>
<li>使光标移动到屏幕最上方：H high</li>
<li>使光标移动到屏幕最下方：L low</li>
<li>使光标移动到屏幕中间：M middle</li>
</ul>
<h2><a id="%E6%96%87%E6%9C%AC%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本修改</h2>
<ul>
<li>d 加动作来进行删除（dd 删除整行）；D 则相当于 d$，删除到行尾。</li>
<li>c 加动作来进行修改（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模式。</li>
<li>s 相当于 cl，删除一个字符然后进入插入模式；S 相当于 cc，替换整行的内容。</li>
<li>i 在当前字符前面进入插入模式；I 则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。</li>
<li>a 在当前字符后面进入插入模式；A 相当于 $a，把光标移到行尾然后进入插入模式。</li>
<li>o 在当前行下方插入一个新行，然后在这行进入插入模式；O 在当前行上方插入一个新行，然后在这行进入插入模式。</li>
<li>r 替换光标下的字符；R 则进入替换模式，每次按键（直到 ）替换一个字符。</li>
<li>u 撤销最近的一个修改动作；U 撤销当前行上的所有修改。</li>
<li>gU gu 使用v选中字符后，输入gU或gu可使选中文本变成大写或小写</li>
</ul>
<h2><a id="%E6%96%87%E6%9C%AC%E9%80%89%E6%8B%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本选择</h2>
<ul>
<li>i: 如：di), 删除()内所有内容，不包括()</li>
<li>a: 如：ca&quot;, 修改&quot;&quot;内包括&quot;&quot;在内的所有内容</li>
<li>用v选中后
<ul>
<li>&lt; &gt;, 左右缩进</li>
<li>= 自动缩进</li>
<li>J 内联成一行</li>
</ul>
</li>
<li>[C-v], 选中多行文本
<ul>
<li>用A或I插入文本，输入ESC，会在选中的多行文本重复执行相同插入文本操作</li>
</ul>
</li>
</ul>
<h2><a id="%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重复执行</h2>
<ul>
<li>; 重复最近的字符查找（f、t 等）操作</li>
<li>, 重复最近的字符查找操作，反方向</li>
<li>n 重复最近的字符串查找操作（/ 和 ?）</li>
<li>N 重复最近的字符串查找操作（/ 和 ?），反方向</li>
<li>. 重复执行最近的修改操作</li>
</ul>
<h2><a id="%E5%A4%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多文件操作</h2>
<ul>
<li>:args 列出打开文件列表</li>
<li>:n 打开下一个文件</li>
<li>:N 打开上一个文件</li>
<li>:ls 列出缓冲区列表</li>
<li>:bnext 切换到下一个缓冲区</li>
<li>:bprev 切换到前一个缓冲区</li>
<li>:b 序号 切换到对应序号的缓冲区</li>
<li>[C-^] 在最近编辑的文件之间切换Aug 16, 2020S</li>
</ul>
<h2><a id="%E5%A4%9A%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多窗口操作</h2>
<ul>
<li>:sp 或 [C+w]s 水平拆分</li>
<li>:vs 或 [C+w]v 垂直拆分</li>
<li>[C+w]w 窗口切换</li>
<li>[C+w]c 关闭窗口，最后一个窗口无效</li>
<li>[C+w]q 退出窗口，最后一个窗口退出整个vim</li>
<li>[C+w]= 平均调整每个窗口大小</li>
<li>:tabnew 新建标签页</li>
<li>:gt, :gT 切换标签页</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/7/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15949090783980.html">
                
                  <h1>一些终端下更好用的替代工具</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="ls%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ls的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info exa
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># exa -l --tree -L 1
</code></pre>
<p>用列表加树状展示一级目录下的目录和文件</p>
<h2><a id="cat%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cat的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info bat
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># bat README.md
</code></pre>
<p>比cat增加高亮和对git状态的支持</p>
<h2><a id="find%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>find的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info fd
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># fd README.md
</code></pre>
<p>语法比find简单，默认忽略.gitignore里的文件和隐藏文件</p>
<h2><a id="grep%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>grep的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info rg
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># rg xxx
</code></pre>
<p>显示漂亮，默认忽略.gitignore文件和隐藏文件，默认递归所有子文件夹，可以指定文件类型</p>
<h2><a id="cd%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cd的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info z
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># z de [Tab]
</code></pre>
<p>自动基于历史访问过的以de开头的目录进行补全</p>
<pre class="line-numbers"><code class="language-plain_text"># brew info fzf
</code></pre>
<pre class="line-numbers"><code class="language-plain_text"># cd $(find * -type d | fzf)
</code></pre>
<p>通过上下键选择需要访问的目录，回车进入。</p>
<p>fzf会把标准输出变成交互式下拉列表共用户选择。</p>
<h2><a id="%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件管理的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info nnn
</code></pre>
<h2><a id="%E7%9C%8B%E6%97%A5%E5%BF%97tail%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>看日志tail的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info lnav
</code></pre>
<p>支持各种日志的高亮显示，支持正则匹配</p>
<h2><a id="man%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>man的替代工具</h2>
<pre class="line-numbers"><code class="language-plain_text"># brew info
</code></pre>
<hr />
<p><img src="http://image.harveygg.wang/mweb/15951458383567.jpg" alt="" /></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/7/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15588383364141.html">
                
                  <h1>(2) MAC开发环境——终端+Shell</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="http://image.harveygg.wang/mweb/Jietu20190526-225814.jpg" alt="Jietu20190526-225814" /><br />
最终效果！</p>
<h2><a id="iterm2-https-iterm2-com" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://iterm2.com/">iTerm2</a></h2>
<p><img src="http://image.harveygg.wang/mweb/iterm2.jpg" alt="iter" /></p>
<p>iTerm2 是 MAC 下最好的终端工具。<br />
可以使用Homebrew来安装：</p>
<pre class="line-numbers"><code class="language-shell">$ brew cask install iterm2
</code></pre>
<hr />
<p>iTerm2 的一些特色功能如下。</p>
<h3><a id="%E6%A0%87%E7%AD%BE%E5%8F%98%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标签变色</h3>
<p>iTerm2的tab会通过变色来提示当前tab下的任务有新活动，有新的输出时tab会变成洋红色，新的输出长时间没看，tab会变成红色。</p>
<h3><a id="%E6%99%BA%E8%83%BD%E9%80%89%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>智能选中</h3>
<p>在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）</p>
<p>在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。</p>
<p>使用CMD+F打开搜索，然后输入需要复制的内容开头关键字，如IP的第一节，搜到后按Tab键，智能选中需要复制的内容并且已经拷贝到剪贴板。</p>
<h3><a id="%E5%B7%A7%E7%94%A8%E2%8C%98cmd%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>巧用⌘(CMD)键</h3>
<p>按住⌘键:</p>
<ul>
<li>可以拖拽选中的字符串；</li>
<li>点击url：调用默认浏览器访问该网址；</li>
<li>点击文件：调用默认程序打开文件；</li>
<li>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；</li>
<li>点击文件夹：在 finder 中打开该文件夹；</li>
</ul>
<h3><a id="%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用快捷键</h3>
<ul>
<li>切换tab：<code>⌘+←</code>, <code>⌘+→</code>, <code>⌘+{</code>, <code>⌘+}</code>。⌘+数字直接定位到该tab；</li>
<li>新建 tab：<code>⌘+t</code>；</li>
<li>顺序切换pane：<code>⌘+[</code>, <code>⌘+]</code>；</li>
<li>切分屏幕：<code>⌘+d</code>水平切分，<code>⌘+shift+d</code> 垂直切分；</li>
<li>按方向切换pane：<code>⌘+Option+方向键</code>；</li>
<li>智能查找，支持正则查找：<code>⌘+f</code>；</li>
<li>显示光标位置：<code>⌘+/</code></li>
<li>增加标记，然后跳回标记：<code>⌘+shift+M</code>标记，<code>⌘+shift+J</code>跳回标记，<code>⌘+shift+up/down</code>在标记间切换</li>
<li>显示历史剪贴板所有内容：<code>⌘+shift+H</code></li>
<li>按时间轴显示快照：<code>⌘+option+B</code></li>
</ul>
<h3><a id="%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动完成</h3>
<p>iTerm2可以自动补齐命令，输入若干字符，按<code>⌘+;</code>弹出自动补齐窗口，列出曾经使用过的命令。</p>
<p><img src="http://image.harveygg.wang/mweb/15588871124877.jpg" alt="" style="width:617px;" /></p>
<h3><a id="%E9%85%8D%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配色</h3>
<p>你可以自由定制喜欢的配色，<a href="https://iterm2colorschemes.com/">这里</a>收集了大量iTerm2的主题。在其github repo里下载对应的xxx.itermcolors文件安装，安装方法如下：</p>
<ul>
<li>打开iTerm2</li>
<li>按<code>⌘+i</code></li>
<li>选中<code>Colors</code>tab</li>
<li>点击<code>Load Presets</code></li>
<li>点击<code>Import</code></li>
<li>选择你需要的<code>.itermcolors</code>文件</li>
<li>再次点击<code>Load Presets</code>选择刚刚导入的主题</li>
</ul>
<p><img src="http://image.harveygg.wang/mweb/15588872205753.jpg" alt="" style="width:609px;" /></p>
<hr />
<p>但是最理想的配色方案在这里<a href="https://github.com/altercation/solarized">https://github.com/altercation/solarized</a></p>
<pre class="line-numbers"><code class="language-shell">$ git clone https://github.com/altercation/solarized.git
</code></pre>
<ol>
<li>进入solarized/iterm2-colors-solarized 下双击<code>Solarized Dark.itermcolors</code>和<code>Solarized Light.itermcolors</code>两个文件就可以把明暗两种配置文件导入到iTerm2里</li>
<li>通过load presets选择刚刚安装的配色主题即可</li>
</ol>
<p><img src="http://image.harveygg.wang/mweb/Jietu20190527-001007.jpg" alt="Jietu20190527-001007" /></p>
<h2><a id="zsh-https-zhuanlan-zhihu-comp19556676" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://zhuanlan.zhihu.com/p/19556676">ZSH</a></h2>
<p>MAC默认自带终极shell!</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/21418449">为什么说zsh是shell中的极品</a></p>
</blockquote>
<p>修改默认bash</p>
<pre class="line-numbers"><code class="language-shell">$ chsh -s /bin/zsh
</code></pre>
<h3><a id="oh-my-zsh-https-ohmyz-sh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://ohmyz.sh/">Oh My ZSH</a></h3>
<p><img src="http://image.harveygg.wang/mweb/omzsh.png" alt="omzsh" /></p>
<blockquote>
<p>Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout...</p>
</blockquote>
<blockquote>
<p>“Oh My ZSH!”</p>
</blockquote>
<h4><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h4>
<pre class="line-numbers"><code class="language-plain_text">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>
<h4><a id="%E9%85%8D%E7%BD%AEoh-my-zsh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置oh my zsh</h4>
<blockquote>
<p><a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh github</a></p>
</blockquote>
<h3><a id="agnoster%E4%B8%BB%E9%A2%98-https-github-comfcambloroh-my-zsh-agnoster-fcamblor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor">agnoster主题</a></h3>
<p>agnoster是一个zsh主题，特别为使用iTerm2 + Solarized Dark主题，又经常使用Git的用户定制。</p>
<h4><a id="%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装</h4>
<pre class="line-numbers"><code class="language-shell">$ git clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git
</code></pre>
<p>执行工程里的install脚本，主题将安装到~/.oh-my-zsh/themes目录下</p>
<h4><a id="%E8%AE%BE%E7%BD%AE%E8%AF%A5%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置该主题</h4>
<p>打开~/.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。<br />
<img src="http://image.harveygg.wang/mweb/15588877098383.jpg" alt="" style="width:618px;" /></p>
<h3><a id="%E5%A2%9E%E5%8A%A0%E6%8C%87%E4%BB%A4%E9%AB%98%E4%BA%AE%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增加指令高亮效果</h3>
<p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮</p>
<h4><a id="%E5%AE%89%E8%A3%85zsh-syntax-highlighting-https-github-comzsh-userszsh-syntax-highlighting" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a></h4>
<pre class="line-numbers"><code class="language-shell">$ git clone git://github.com/zsh-users/zsh-syntax-highlighting.git
$ echo &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc
</code></pre>
<h3><a id="%E5%AE%89%E8%A3%85powerline-http-powerline-readthedocs-ioenlatestinstallation-html" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="http://powerline.readthedocs.io/en/latest/installation.html">安装Powerline</a></h3>
<pre class="line-numbers"><code class="language-shell">$ pip install powerline-status --user
</code></pre>
<h3><a id="%E5%AE%89%E8%A3%85powerline%E5%AD%97%E4%BD%93%E5%BA%93-https-link-jianshu-com-t-https-3a-2f-2fgithub-com-2fpowerline-2ffonts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fpowerline%2Ffonts">Powerline字体库</a></h3>
<p>使用zsh主题需要配合Powerline字体</p>
<ol>
<li>将工程clone下来</li>
<li>执行install.sh脚本安装所有Powerline字体</li>
</ol>
<p>安装完成后提示所有字体均已下载到/Users/{username}/Library/Fonts路径下</p>
<h4><a id="%E8%AE%BE%E7%BD%AEiterm2%E7%9A%84%E5%AD%97%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置iTerm2的字体</h4>
<p>具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，选择for Powerline的字体</p>
<p><img src="http://image.harveygg.wang/mweb/15588954739813.jpg" alt="" style="width:830px;" /></p>
<hr />
<blockquote>
<p>Maybe you also want to try <a href="https://jmolivas.weknowinc.com/improve-your-shell-using-fish-and-oh-my-fish">this</a></p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15750321018543.html">
                
                  <h1>安全和隐私中“任何来源”找回办法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>苹果发布了<code>MacOS Sierra 10.12</code>版本之后，原来需要用于安装从网上下载的软件的功能不见了，即系统中“任何来源”选项。可以使用如下方法找回“任何来源”的选项。</p>
<p>在终端中输入</p>
<pre class="line-numbers"><code class="language-shell">sudo spctl --master-disable
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15763252898733.html">
                
                  <h1>人类能否造出真正智能的机器人？</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>机器人是什么？<br />
是计算机。<br />
计算机是什么？<br />
冯诺依曼结构的计算机可以抽象为“输入”、“计算”和“输出”三部分。<br />
计算机的智能体现在其扩展能力上。<br />
其输入从最早的打孔纸带扩展到现在的键盘，鼠标、语音，传感器等。<br />
其计算能力可以通过编程来扩展。<br />
其输出从最初的显示器扩展到现在的扬声器、打印机、投影仪等。<br />
机器人的智能体现在，对于不同输入都可以给出“智能”的输出。这个“智能”体现在其处理逻辑会随着处理其他输入而自动升级。表现出会学习的特征。<br />
何为非真正智能的机器人？<br />
不会主动“思考”、“学习”的机器人就不是真正智能的机器人。<br />
如果机器人能够主动的“思考”、“学习”了之后，他和人类有什么区别？<br />
他应该从能力上超过人类。<br />
为了想清楚机器人是否可能最终成为真正“智能”的机器人，我们需要把机器人和人类做一下对比。<br />
然而我认为人类其实也是遵循冯诺依曼结构工作的！<br />
人类刚出生时对于绝大多数输入是没有反应的，即还不具备对输入的计算能力。<br />
随着被动学习，对于固定输入的计算逻辑建立起来了。此时开始模仿，即对于给定的输入，其计算逻辑始终不变，只是越算越快，这是一个熟练过程。<br />
然而人类刚出生也不是对所有输入都没有计算能力的，比如对于疼痛的计算，对于饥饿的计算，对于光线的计算……<br />
随着年龄长大，逐渐体现出对于一些输入会输出嫉妒、气愤、喜欢……<br />
这些其实是人类的基因决定的。<br />
那基因是什么？<br />
其实就是随着人类从远古到现代的进化中积累下来的计算逻辑。比如，人类有攀比心，其实是对于比自己好这个输入的计算，其输出是我要超过他的激素刺激。<br />
正是因为人类天生具备七宗罪的天性基因，才让人类得以主动思考，主动学习。<br />
所以，如果可以破解人类基因，并且给机器人输入这些基因程序，则机器人就可以和人类一样智能。在不给机器人任何输入的情况下，机器人也会基于这个“没有任何输入”的信号，并结合之前的记忆去计算然后表现出机器人在“思考”……</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='architecture-designing.html'>架构设计</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15771545679019.html">
                
                  <h1>DDD学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是领域驱动</h2>
<h3><a id="%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据模型驱动</h3>
<p>传统服务建模的过程是先通过业务分析数据模型，然后在关系型数据库上基于范式设计数据库表以及表之间的关系。最后通过ORM建立起数据持久化对象和数据库表之间的映射。还要通过数据访问对象(DAO)来操作数据持久化对象。</p>
<p>由于持久化对象和数据访问对象都不包含业务逻辑，服务就成为了业务逻辑的唯一栖身之地。这时，持久化对象是数据的提供者，实现服务时就会非常自然地选择事务脚本（Transaction Script）模式。</p>
<p>《企业应用架构模式》对事务脚本的定义为：</p>
<blockquote>
<p>使用过程来组织业务逻辑，每个过程处理来自表现层的单个请求。这是一种典型的过程式设计，每个服务功能都是一系列步骤的组合，从而形成一个完整的事务。注意，这里的事务代表一个完整的业务行为过程，而非保证数据一致性的事务概念。</p>
</blockquote>
<p>不要因为事务脚本采用面向过程设计就排斥这一模式，相较于对编程范式的偏执，我认为 Martin Fowler 在书中说的一句话更加公道：</p>
<blockquote>
<p>“不管你是多么坚定的面向对象的信徒，也不要盲目排斥事务脚本。许多问题本身是简单的，一个简单的解决方案可以加快你的开发速度，而且运行起来也会更快。”</p>
</blockquote>
<p>即使采用事务脚本，我们也可以通过提取方法来改进代码的可读性。每个方法都提供了一定的抽象层次，通过方法的提取就可以在一定程度上隐藏细节，保持合理的抽象层次。这种方式被 Kent Beck 总结为组合方法（Composed Method）模式：</p>
<ul>
<li>把程序划分为方法，每个方法执行一个可识别的任务</li>
<li>让一个方法中的所有操作处于相同的抽象层</li>
<li>这会自然地产生包含许多小方法的程序，每个方法只包含少量代码</li>
</ul>
<h3><a id="%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E9%A9%B1%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域建模驱动</h3>
<p>领域建模驱动是相对于数据建模驱动的。<br />
领域建模驱动要先识别出领域，确定领域模型，然后再确定技术实现方案。<br />
识别领域确定领域模型的过程需要分析清楚问题域，理清业务。所以领域驱动设计倡导的是从问题出发，先分析问题域得到业务，然后结合业务、规模、系统结构进行设计，然后再编码实现。</p>
<ul>
<li>问题域——客户的需求</li>
<li>解决方案域——需求的实现</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">问题-&gt;领域-&gt;业务逻辑-&gt;规模-&gt;结构-&gt;实现
</code></pre>
<h2><a id="ddd%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AA%81%E7%84%B6%E7%81%AB%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD为什么突然火了</h2>
<p>微服务的划分粒度如何把握。</p>
<blockquote>
<p>纵观软件设计的历史，不是分久必合、合久必分，而是不断拆分、持续拆分的微型化过程。</p>
</blockquote>
<p>限界上下文(Bounded Context)有利于确定微服务的划分。</p>
<p>理论上：</p>
<ul>
<li>一个微服务不要小于一个聚合</li>
<li>一个微服务不要大于一个限界上下文</li>
</ul>
<p>如果出现如下情况说明微服务划分不合理：</p>
<ul>
<li>微服务间经常需要分布式事务来支持业务数据一致性</li>
<li>对于微服务A来说，处理一个请求总是依赖另一个微服务B</li>
<li>一个微服务中出现多个名字相同的领域实体</li>
</ul>
<h2><a id="ddd%E7%9A%84%E4%BB%B7%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的价值</h2>
<blockquote>
<p>应对软件复杂度</p>
</blockquote>
<ul>
<li>从领域出发，保证软件分析模型和设计模型一致，业务人员和开发协作，保证软件质量</li>
<li>提出统一语言，确保所有概念在各自的上下文中清晰无歧义</li>
<li>提出分层架构，有效分离业务和技术，同时从垂直方向上做分隔职责边界</li>
<li>战略设计通过拆分子域和限界上下文，从横向上分隔离职责边界</li>
<li>战术设计通过引入多种领域模型概念帮助领域模型设计落地</li>
<li>引入微服务间协作的设计模式</li>
</ul>
<h3><a id="%E8%BD%AF%E4%BB%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%8D%E6%9D%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>软件为什么会复杂</h3>
<p>主观可控：</p>
<ul>
<li>业务规则 <em>复杂</em></li>
<li>需求变化 <em>不可预测</em></li>
<li>规模变 <em>大</em></li>
<li>结构变 <em>复杂</em></li>
<li>技术选型 <em>升级</em></li>
</ul>
<p>主观不可控：</p>
<ul>
<li>人不够</li>
<li>人员流动</li>
<li>时间紧</li>
<li>组织架构不合理</li>
</ul>
<h3><a id="%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何应对软件复杂</h3>
<p><strong>关注点分离（Separation of Concern）</strong></p>
<ul>
<li>分离业务和技术
<ul>
<li>分层架构
<ul>
<li>六边形架构</li>
<li>整洁架构</li>
</ul>
</li>
<li>分层
<ul>
<li>UI层（User Interface Layer）</li>
<li>应用层（Application Layer）</li>
<li>领域层（Domain Layer）</li>
<li>技术设施层（Infrastructure Layer）</li>
</ul>
</li>
<li>设计原则
<ul>
<li>SRP (Single-Responsibility Principle)</li>
<li>DIP (Dependency inversion principle)</li>
<li>Interface-Oriented Programming</li>
<li>Dependency Injection</li>
</ul>
</li>
</ul>
</li>
<li>分离职责
<ul>
<li>限界上下文</li>
<li>聚合</li>
<li>领域</li>
</ul>
</li>
</ul>
<p><img src="media/15771545679019/15771737688932.jpg" alt="" /></p>
<p><img src="media/15771545679019/15771749354517.jpg" alt="" /></p>
<h2><a id="ddd%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的设计过程</h2>
<p><img src="media/15771545679019/15771554676189.jpg" alt="" /></p>
<h3><a id="%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战略设计阶段</h3>
<ul>
<li>问题域
<ul>
<li>限界上下文（Bounded Context）</li>
<li>上下文映射（Context Map）</li>
<li>核心域（Core Domain）</li>
<li>子域（Subdomain）</li>
</ul>
</li>
<li>架构
<ul>
<li>六边形架构</li>
<li>整洁架构</li>
<li>CQRS</li>
<li>Event Sourcing</li>
</ul>
</li>
</ul>
<h3><a id="%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战术设计阶段</h3>
<ul>
<li>值对象（Value Object）</li>
<li>实体（Entity）</li>
<li>领域服务（Domain Service）</li>
<li>领域事件（Domain Event）</li>
<li>资源库（Repository）</li>
<li>工厂（Factory）</li>
<li>聚合（Aggregate）</li>
<li>应用服务（Application Service）</li>
</ul>
<p><img src="media/15771545679019/15771569102713.jpg" alt="" /></p>
<h3><a id="%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个完整的生命周期</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>参与者</th>
<th>产出物</th>
</tr>
</thead>
<tbody>
<tr>
<td>需求</td>
<td>产品经理、客户</td>
<td>需求文档</td>
</tr>
<tr>
<td>KickOff</td>
<td>产品经理、客户、开发负责人、测试负责人</td>
<td>明确利益相关人、对业务的共同理解、识别主要用户故事</td>
</tr>
<tr>
<td>事件风暴</td>
<td>领域专家、产品经理、DDD专家、架构师、相关开发</td>
<td>统一语言、领域模型</td>
</tr>
<tr>
<td>架构设计</td>
<td>架构师、DDD专家</td>
<td>代码包结构、技术选型、系统间通信方式</td>
</tr>
<tr>
<td>开发</td>
<td>架构师、开发</td>
<td>单元测试、代码实现</td>
</tr>
<tr>
<td>演示</td>
<td>产品经理、开发负责人、测试负责人、领域专家、客户</td>
<td>客服意见</td>
</tr>
<tr>
<td>测试</td>
<td>测试</td>
<td>测试报告</td>
</tr>
<tr>
<td>交付</td>
<td>运维、开发、测试</td>
<td>服务</td>
</tr>
</tbody>
</table>
<h2><a id="%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8F%90%E7%82%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域模型的提炼</h2>
<p><img src="media/15771545679019/15776877632436.jpg" alt="" /></p>
<h3><a id="6w%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6W模型</h3>
<ul>
<li>Who: 角色，一个场景中参与的用户是什么角色</li>
<li>Why: 价值，解决用户什么问题</li>
<li>What: 功能，需要做什么</li>
<li>When: 流程，具体的业务逻辑是什么</li>
<li>Where: 边界，场景的边界</li>
<li>How: 实现，具体的技术实现</li>
</ul>
<h3><a id="%E5%A6%82%E4%BD%95%E5%AE%9E%E6%96%BD6w%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何实施6W模型</h3>
<h4><a id="1%E7%94%A8%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 用例</h4>
<pre class="line-numbers"><code class="language-plain_text">用例名称：批量增加主机
用例目的（Why）：本用例可以帮助「角色（Who）」为其微服务一次性关联（What）符合「条件」的主机
参与者（Who）：「角色」
前置条件：微服务已经被纳管

基础流程（When）：
1. ……
2. ……
3. ……

替代流程：异常情况一
替代流程：异常情况二
</code></pre>
<h4><a id="2-tdd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. TDD</h4>
<pre class="line-numbers"><code class="language-java">@Autowared
private HostAppService hostAppService;

@Test
// 测试方法以描述业务的形式命名
// 不要对被测试方法写单元测试，要对领域场景编写，驱动我们识别场景分解任务
public void should_return_100_when_100_valid_hosts_registered_successfully() {
    // given 驱动我们思考对象的创建，与其他对象的协作，领域对象的命名（统一语言）
    Microservice microservice = Mock.one(Microservice.class);
    List&lt;Host&gt; validHosts = validHosts(100);
    
    // when 驱动我们思考职责边界、方法的命名、入参
    int successAmount = hostAppService.registerHostsForMicroservice(microservice, validHosts)
}
    
    // then 驱动我们思考方法的返回值、对系统的其他影响
    AssertThat(successAmount, is(100));
</code></pre>
<h2><a id="%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>统一语言</h2>
<ul>
<li>通过事件风暴获得统一语言的中文</li>
<li>标注对应英文</li>
<li>引入局外人对用例的阐述进行提问</li>
<li>统一语言要具备专业性（水，H2O）</li>
</ul>
<h2><a id="%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限界上下文</h2>
<p>限界上下文需要满足四个特征：</p>
<ul>
<li>最小完备：要完备，而且要最小；不依赖外部</li>
<li>自我履行：知识专家，基于掌握的知识决定需要履行的职责，不做边界外的职责</li>
<li>稳定空间：分离内外，外部变化对内不影响</li>
<li>独立进化：自身进化对外不影响</li>
</ul>
<h3><a id="%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>识别限界上下文</h3>
<p>识别限界上下文就是寻找边界：基于业务边界、技术边界，找到限界上下文的边界，进而找到工作边界、应用边界。</p>
<p><img src="media/15771545679019/15785351896389.jpg" alt="" /></p>
<h3><a id="%E9%AA%8C%E8%AF%81%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>验证识别结果</h3>
<ul>
<li>是否能给限界上下文轻松的命名</li>
<li>限界上下文之间是否容易协作</li>
</ul>
<h3><a id="%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上下文协作关系</h3>
<p><img src="media/15771545679019/15794115154549.jpg" alt="" /></p>
<p>上下文映射模式：</p>
<ol>
<li>合作关系（Partnership）</li>
<li>共享内核（Shared Kernel）</li>
<li>客户方-供应方开发（Customer-Supplier Development）</li>
<li>遵奉者（Conformist）</li>
<li>分离方式（Separate Ways）</li>
</ol>
<p>降低上下文之间耦合的模式：</p>
<ol>
<li>防腐层（Anticorruption Layer）</li>
<li>开放主机服务（Open Host Service）</li>
<li>发布/订阅事件</li>
</ol>
<p>附：《实现领域驱动设计》里的9种组织模式和集成模式</p>
<pre class="line-numbers"><code class="language-plain_text">①合作关系（Partnership）

如果2个限界上下文的团队要么一起成功，要么一起失败，此时就是这种关系。应该为相互关联的软件功能制定好计划表，这样可以确保这些功能在同一个发布中完成。

②共享内核（Shared Kernel）
   
对模型和代码的共享将产生一种紧密的依赖性，对于设计来说，这种依赖性可好可坏。我们需要为共享的部分模型指定一个显式边界，并保持共享内核的小型化。共享内核具有特殊的状态，在没有与另一个团队协商的情况下，这种状态是不能改变的。我们应该引入一种持续集成过程来保证共享内核与通用语言的一致性。

③客户方——供应方（Customer-Supplier Development）

当2个团队处于一种上游——下游关系时，上游团队可能独立于下游团队完成开发，此时下游团队的开发可能会受到很大的影响。因此，在上游团队的计划中，我们应该顾及到下游团队的需求。

④遵奉者（Conformist）

在存在上游——下游关系的2个团队中，如果上游团队已经没有动力提供下游团队之需，下游团队便孤军无助了。处于利他主义，上游团队可能向下游团队做出种种承诺，但是有很大的可能是：这些承诺是无法实现的。下游团队只能盲目地使用上游团队模型。

⑤防腐层（Anticorruption Layer）

在集成2个设计良好的限界上下文时，翻译层可能很简单，甚至可以很优雅的实现。但是，当共享内核，合作关系或客户方——供应方关系无法顺利实现时，此时的翻译将变得复杂。对于下游客户来说，你需要根据自己的领域模型创建一个单独的层，该层作为上游系统的委派向你的系统提供功能。防腐层通过已有的接口与其他系统交互，而其他系统只需要做很小的修改，甚至无需修改。在防腐层内部，它在你自己的模型和他方模型之间进行翻译转换。【为每个防腐层定义相应的领域服务】

⑥开放主机服务（Open Host Service）

定义一种协议，让你的子系统通过该协议来访问你的服务。并且需要将协议公开。

⑦发布语言（Published Language）

在2个限界上下文之间翻译模型需要一种公用的语言。此时你应该使用一种发布出来的共享语言来完成集成交流。发布语言通常与开放主机服务一起使用。

⑧另谋他路（SeparateWay）

在确定需求时，我们应该做到坚持彻底。如果2套功能没有显著的关系，那么它们是可以被完全解耦的。集成总是昂贵的，有时带给你的好处也不大。声明2个限界上下文之间不存在任何关系，这样使得开发者去另外寻找简单的、专门的方法来解决问题。

⑨大泥球（Big Ball of Mud）

当我们检查已有系统时，经常会发现系统中存在混杂在一起的模型，它们之间的边界是非常模糊的。此时你应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。在这个边界内，不要试图使用复杂的建模手段来化解问题。同时，这样的系统有可能会向其他系统蔓延，应该对此保持警觉。
</code></pre>
<h3><a id="%E5%88%92%E5%88%86%E5%9B%A2%E9%98%9F%E5%92%8C%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>划分团队和应用</h3>
<ul>
<li>基于语义相关性和功能相关性识别出限界上下文</li>
<li>基于<code>2PTs规则</code>、<code>特性团队</code>、<code>康威定律</code>思想划分团队，找到工作边界</li>
<li>基于<code>重用性</code>、<code>业务变化</code>、<code>质量属性</code>、<code>技术选型</code>等技术考虑划分应用边界，并持续重构</li>
</ul>
<h2><a id="%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E4%BA%A7%E5%87%BA%E7%89%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>战略设计阶段产出物</h2>
<ol>
<li>利益相关人</li>
<li>业务期望和愿景</li>
<li>项目业务范围</li>
<li>业务流程</li>
<li>史诗级故事和主故事</li>
<li>根据核心参与者识别用例，输出每个参与者的用例图</li>
<li>根据语义相关性和功能相关性识别出用例主题边界，输出用例主题</li>
<li>根据主题之间的相关性识别限界上下文</li>
<li>上下文映射图或表</li>
<li>输出架构4+1视图
<ol>
<li>逻辑视图：限界上下文图；上下文映射图；分层架构</li>
<li>进程视图：限界上下文图；六边形架构；上下文映射</li>
<li>物理视图：六边形架构</li>
<li>开发视图：分层架构；代码模型</li>
<li>场景视图：领域场景分析；用例图</li>
</ol>
</li>
</ol>
<h3><a id="%E6%9E%B6%E6%9E%844-1%E8%A7%86%E5%9B%BE%E4%B8%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>架构4+1视图举例</h3>
<h4><a id="1%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 逻辑视图</h4>
<p><img src="media/15771545679019/15833010184246.jpg" alt="" /></p>
<p>视图说明</p>
<ul>
<li>系统层次的分层架构</li>
<li>限界上下文层次的分层架构</li>
</ul>
<h4><a id="2%E8%BF%9B%E7%A8%8B%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 进程视图</h4>
<p><img src="media/15771545679019/15833010852284.jpg" alt="" /></p>
<p>视图说明</p>
<ul>
<li>在绘制系统的进程视图时，不需要将每个牵涉到进程间调用的用例场景都展现出来，而是将这些参与协作的组件以抽象方式表达一个典型的全场景即可。</li>
<li>整个进程视图非常清晰地表达了部署在不同进程之上的组件或子系统之间的协作关系，同时通过图例体现了领域驱动设计中的北向网关和南向网关与外部资源之间的协作。调用的方式是同步还是异步，也一目了然。</li>
</ul>
<h4><a id="3%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. 物理视图</h4>
<p><img src="media/15771545679019/15833011711307.jpg" alt="" /></p>
<p>物理视图与进程视图虽然都以进程边界为主要的设计单元，但二者的关注点不同。进程视图是动态的，体现的是外部环境、系统各个组件在进程之间的协作方式与通信机制；物理视图是静态的，主要体现系统各个模块以及系统外部环境的部署位置与部署方式。</p>
<h4><a id="4%E5%BC%80%E5%8F%91%E8%A7%86%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. 开发视图</h4>
<p><img src="media/15771545679019/15833012202839.jpg" alt="" /></p>
<ul>
<li>给出代码分层结构</li>
<li>分别体现出系统级代码分层结构和限界上下文内的代码分层结构</li>
</ul>
<h2><a id="%E5%AE%9E%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实体</h2>
<h2><a id="%E5%80%BC%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>值对象</h2>
<h2><a id="%E8%81%9A%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合</h2>
<p>引入聚合来划分对象之间的边界，保证边界内所有对象的一致性。其中作为主体的实体对象是聚合根。</p>
<h3><a id="%E8%81%9A%E5%90%88%E8%BE%B9%E7%95%8C%E7%9A%84%E8%AF%86%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合边界的识别</h3>
<ul>
<li>是否多实体同生命周期，同生同死组合关系（完整性）</li>
<li>是否单实体有独立性需求，外界需要直接和他交互（独立性）</li>
<li>是否存在不变量</li>
<li>是否处于一个事务中</li>
</ul>
<h3><a id="%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>规则</h3>
<ul>
<li>外界只能和聚合根交互</li>
<li>聚合根可以向外部传递内部实体的引用，但外部对象只能临时使用</li>
<li>聚合根可以向外部传递值对象的副本</li>
<li>只有聚合根才能直接通过数据库获得，其他实体通过聚合根获得</li>
</ul>
<h2><a id="%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域服务</h2>
<p>存在跨聚合的业务场景时需要使用领域服务</p>
<h2><a id="%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分层架构</h2>
<p>传统三层架构和领域驱动经典四层架构的对比：</p>
<p><img src="media/15771545679019/15802181588889.jpg" alt="" /><br />
经典三层架构</p>
<p><img src="media/15771545679019/15802181811457.jpg" alt="" /><br />
Eric Evans 在其经典著作《领域驱动设计》中的四层架构</p>
<ul>
<li>领域驱动四层架构多引入了<code>Application Layer</code></li>
<li><code>业务逻辑层</code>改名为<code>Domain Layer</code>，定位更具体</li>
<li><code>数据访问层</code>的名字变为<code>Infrastructure Layer</code>，职责扩大</li>
</ul>
<h3><a id="%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对比分析</h3>
<p>优化后的分层架构通过引入<code>Application Layer</code>，使<code>Domain Layer</code>可以专注业务逻辑，不依赖外部环境，更内聚。<br />
<code>Infrastructure Layer</code>用来分离业务和技术关注点，并不只用来请求数据。</p>
<h3><a id="%E4%BC%A0%E7%BB%9F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%8D%87%E7%BA%A7%E5%88%B0ddd%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>传统三层架构升级到DDD四层架构</h3>
<p><img src="media/15771545679019/15802218910157.jpg" alt="" /><br />
三层架构代码模型</p>
<p><img src="media/15771545679019/15802220571963.jpg" alt="" /><br />
把Java Beans变成充血模型的POJO，并迁移到业务逻辑层。此时POJO对应DDD的Entity和Value Object，业务逻辑层变为领域层。此时领域层和基础设施层相互依赖。</p>
<p><img src="media/15771545679019/15802221495986.jpg" alt="" /><br />
通过依赖反转和依赖注入解耦领域层到基础设施层的依赖。但多了一层基础设施的抽象层。</p>
<p><img src="media/15771545679019/15802223804941.jpg" alt="" /><br />
通过DDD的Repository概念，使基础设施抽象层进入领域层。此时用户展现层仍然直接依赖领域层，领域层对外暴露太多细节。</p>
<p><img src="media/15771545679019/15802224971320.jpg" alt="" /><br />
通过引入开放主机服务，隔离开前端对领域层的直接依赖。但此时通过Controller暴露出去的服务仍然过细。</p>
<p><img src="media/15771545679019/15802226450442.jpg" alt="" /><br />
引入应用层，封装如批量查询、请求跳转、跨领域聚合的业务编排等逻辑。通过Facade模式提供高层接口。到此迁移完毕。</p>
<h3><a id="%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整洁架构</h3>
<p><img src="media/15771545679019/15802197310420.jpg" alt="" /><br />
Robert Martin 提出的整洁架构</p>
<ul>
<li>层次越靠内的组件依赖的内容越少，处于核心的 Entities 没有任何依赖。</li>
<li>层次越靠内的组件与业务的关系越紧密，因而越不可能形成通用的框架。</li>
<li>Entities 层封装了企业业务规则，准确地讲，它应该是一个面向业务的领域模型。</li>
<li>Use Cases 层是打通内部业务与外部资源的一个通道，因而提供了输出端口（Output Port）与输入端口（Input Port），但它对外的接口展现的其实是应用逻辑，或者说是一个用例。</li>
<li>Gateways、Controllers 与 Presenters 其本质都是适配器（Adapter），用于打通应用业务逻辑与外层的框架和驱动器，实现逻辑的适配以访问外部资源。</li>
<li>系统最外层包括框架和驱动器，负责对接外部资源，不属于系统（仅指限界上下文而言）开发的范畴，但选择这些框架和驱动器，是属于设计决策要考虑的内容。这一层的一些组件甚至与要设计的系统不处于同一个进程边界。</li>
</ul>
<h3><a id="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>微服务架构</h3>
<p><img src="media/15771545679019/15802207740226.jpg" alt="" /><br />
Martin Fowler的微服务架构</p>
<p>整幅图的架构其实蕴含了两个方向：自顶向下和由内至外。</p>
<ul>
<li>外部请求通过代表协议（Protocol）的 Resources 组件调用 Service Layer、Domain 或 Repositories，如果需要执行持久化任务，则通过 Repositories 将请求委派给 ORM，进而访问网络边界外的数据库。所谓“外部请求”可以是前端 UI 或第三方服务，而 Resource 组件就是我们通常定义的 Controller，对应于上下文映射中的开放主机服务。之所以命名为 Resources，则是因为 REST 架构是一种面向资源的架构，它将服务操作的模型抽象为资源（Resource），这是自顶向下的方向。</li>
<li>若当前微服务需要调用外部服务（External Service），且外部服务籍由 HTTP 协议通信，就需要提供一个 HTTP Client 组件完成对外部服务的调用。为了避免当前微服务对外部服务的强依赖，又或者对客户端的强依赖，需要引入 Gateways 来隔离。事实上，这里的 Gateways 即为上下文映射中的防腐层，这是由内至外的方向。</li>
</ul>
<h2><a id="ddd%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDD的代码模型</h2>
<p>以电商下单业务为例：</p>
<p><img src="media/15771545679019/15803904268910.jpg" alt="" /></p>
<p>代码结构如下所示：</p>
<pre class="line-numbers"><code class="language-plain_text">ordercontext.infrastructure
    - OrderController
    - OrderMapper
    - EmailSender
    - RabbitEventBus
ordercontext.application
    - OrderAppService
    - NotificationService
    - EventBus
ordercontext.domain
    - OrderRepository
    - PlaceOrderService
    - Order
    - Notification
    - OrderConfirmed
    - NotificationComposer
    - OrderConfirmedComposer
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='architecture-designing.html'>架构设计</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15533542897748.html">
                
                  <h1>微服务设计规范</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E3%80%81%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、六大设计原则</h2>
<h3><a id="1-1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88-open-closed-principle-ocp%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1 开闭原则（Open-Closed Principle, OCP）</h3>
<h4><a id="1-1-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1.1 解释</h4>
<p>开闭原则由Bertrand Meyer于1988年提出，其定义如下：</p>
<ul>
<li>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</li>
</ul>
<h4><a id="1-1-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1.2 好处</h4>
<p>好处显而易见，不修改源码的情况下进行扩展，对已有逻辑没有影响。</p>
<h4><a id="1-1-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1.3 不遵守有什么坏处</h4>
<p>随着软件规模越来越大，软件寿命越来越长，若系统设计不满足开闭原则，则维护成本变得越来越大。修一个bug，又引出10个新bug，最终变得无法维护。</p>
<h4><a id="1-1-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1.4 出现违反原则的原因</h4>
<p>职责不单一是主要影响开闭原则的原因之一；缺乏抽象也会造成开闭原则的破坏。</p>
<h4><a id="1-1-5%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.1.5 实际运用中的取舍</h4>
<p>为了满足开闭原则，需要对系统进行抽象化设计，针对具体业务领域识别出抽象层并抽象化是开闭原则的关键。应用层基于上下文参数识别业务场景，针对不同场景选择不同的实现。</p>
<h3><a id="1-2%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88-dependency-inversion-principle-dip%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2 依赖反转原则（Dependency Inversion  Principle, DIP）</h3>
<h4><a id="1-2-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2.1 解释</h4>
<p>依赖反转原则是Robert C. Martin在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作“Agile Software Development, Principles, Patterns, and Practices”一书中。依赖反转原则定义如下：</p>
<ul>
<li>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</li>
</ul>
<p>要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>
<p>因为正常的依赖顺序是，A依赖B，而为了避免依赖具体实现，引入了抽象层C，使A依赖C，B成为C的具体实现。因为继承、实现关系本身是特殊的依赖关系，所以变成被依赖的实现B反过来依赖C这个抽象层，所以叫依赖反转。</p>
<h4><a id="1-2-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2.2 好处</h4>
<p>依赖反转是实现开闭原则目标的另一个重要手段。</p>
<h4><a id="1-2-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2.3 不遵守有什么坏处</h4>
<p>少了抽象层，很多设计原则都无法做到，后果可想而知。</p>
<h4><a id="1-2-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.2.4 出现违反原则的原因</h4>
<p>这个原则基本上不会违反，因为有了Spring框架提供的依赖注入。</p>
<h3><a id="1-3%E8%81%8C%E8%B4%A3%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99%EF%BC%88-single-responsibility-principle-srp%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3 职责单一原则（Single Responsibility Principle, SRP）</h3>
<h4><a id="1-3-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.1 解释</h4>
<p>把因相同原因而变化的东西聚在一起，把因不同原因而变化的东西分离开来。</p>
<h4><a id="1-3-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.2 好处</h4>
<p>如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<h4><a id="1-3-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.3 不遵守有什么坏处</h4>
<p>修改一段代码，在实现了一个feature升级的同时，影响了另一个feature的功能。</p>
<h4><a id="1-3-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.4 出现违反原则的原因</h4>
<p>职责不单一不是从第一天写代码就开始的，往往是需求变更导致职责拆分后引起的。此时应该将一个方法拆成两个方法，一个类拆成两个类。</p>
<h4><a id="1-3-5%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.5 实际运用中的取舍</h4>
<p>代码结构并不能随着需求的变更每次都做出重构，会影响团队协作效率，需要把握一个度：</p>
<ul>
<li>只有逻辑足够简单，才可以在方法级别上违反单一职责原则</li>
<li>只有类中方法数量足够少，才可以在方法级别上违反单一职责原则</li>
<li>在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。</li>
</ul>
<h3><a id="1-4%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88-liskov-substitution-principle-lsp%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.4 里氏替换原则（Liskov Substitution Principle, LSP）</h3>
<h4><a id="1-4-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.4.1 解释</h4>
<p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。</p>
<ul>
<li>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li>
<li>定义2：所有引用父类的地方必须能透明地使用其子类的对象。</li>
</ul>
<p>可以简单理解为：如果在软件中将一个用父类声明的对象，运行期替换成它的某个子类对象，程序没有产生任何错误和异常，则这个子类的实现是符合里氏替换原则的。</p>
<h4><a id="1-4-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.4.2 好处</h4>
<p>里氏代换原则是实现开闭原则的重要方式之一。由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。从而实现对原有系统的扩展的同时，不影响原有功能。</p>
<h4><a id="1-3-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.3 不遵守有什么坏处</h4>
<p>如果子类集成父类后，又增加了特定的方法，那么只有使用子类来声明对象，这个对象才能使用子类特有的方法，导致后续扩展的时候，必须打开子类来修改代码，没办法替换为父类的其他子类。</p>
<h4><a id="1-3-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.4 出现违反原则的原因</h4>
<p>代码设计初期没有考虑将来复杂性的可能，没有预留好扩展点，直接依赖具体实现，没有使用接口隔离实现。</p>
<h4><a id="1-3-5%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.3.5 实际运用中的取舍</h4>
<p>软件架构往往是分层的，层与层之间必须使用接口隔离实现，层内的具体业务逻辑如果看不到有多种场景下使用多种实现的可能性，暂时可以直接依赖实现。当出现第二种实现时，立即使用接口隔离。<br />
声明对象时，必须使用集成结构中适合当前场景的某一个层级的抽象来声明，不要直接使用子类来声明对象。如：当前需要一个有序可重复队列，则使用List来声明对象，因为Collection过于抽象，无法表达有序可重复的要求，直接使用ArrayList声明，则将来传入LinkedList对象会出错。</p>
<h3><a id="1-5%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88-interface-segregation-principle-isp%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5 接口隔离原则（Interface  Segregation Principle, ISP）</h3>
<h4><a id="1-5-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.1 解释</h4>
<p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<ul>
<li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</li>
<li>如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
</ul>
<h4><a id="1-5-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.2 好处</h4>
<p>容易实现职责单一原则，客户端更容易灵活选择合适的实现，扩展性增强。</p>
<h4><a id="1-5-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.3 不遵守有什么坏处</h4>
<p>接口太大，降低了扩展的灵活性。有时，一个接口中仅仅一个方法在不同场景有不同实现，此时增加一个全新的实现，则新的实现中有大部分代码和已有实现是代码重复的。而且客户端面对一个大接口，失去了根据场景灵活组合实现的可能性，只能定制一个全新的实现来适应当前场景，导致复用变得难以实现。</p>
<h4><a id="1-5-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.4 出现违反原则的原因</h4>
<p>往往初期系统中接口并不大，随着需求的变化，增加了方法，或增加了角色的职责，而没有及时拆分接口。</p>
<h4><a id="1-5-5%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.5.5 实际运用中的取舍</h4>
<p>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<h3><a id="1-6%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88-law-of-demeter-lod%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6 迪米特法则（Law of  Demeter, LoD）</h3>
<h4><a id="1-6-1%E8%A7%A3%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6.1 解释</h4>
<p>迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下：</p>
<ul>
<li>一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ul>
<h4><a id="1-6-2%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6.2 好处</h4>
<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
<h4><a id="1-6-3%E4%B8%8D%E9%81%B5%E5%AE%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%9D%8F%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6.3 不遵守有什么坏处</h4>
<p>不遵守迪米特法则，会使对象间过渡耦合，其结果就是对象间关系过于复杂，而破坏了扩展性和可维护性。</p>
<h4><a id="1-6-4%E5%87%BA%E7%8E%B0%E8%BF%9D%E5%8F%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6.4 出现违反原则的原因</h4>
<p>不要和“陌生人”说话。除以下类型的对象外，其他的都是“陌生人”。缺乏经验的开发，很容易把“陌生人”之间建立起通信关系，使得系统对象间出现不该有的耦合。</p>
<ol>
<li>当前对象本身(this)；</li>
<li>以参数形式传入到当前对象方法中的对象；</li>
<li>当前对象的成员对象；</li>
<li>如果当前对象的成员对象是一个集合，集合中的元素；</li>
<li>当前对象所创建的对象。</li>
</ol>
<p>通常开发容易把本应属于职责边界内的逻辑暴露到外部，调用这段逻辑的客户端代码容易写的过厚，比如客户端依赖n个组件，然后组织n个组件的关系，最后计算出结果，导致客户端和过多的不相关组件通信。其实这n个组件中，很可能大部分逻辑应该封装在几个组件之中，而客户端只需要和少量几个组件通信即可。</p>
<p>当出现连续“.”的方法调用时，比如<code>a.foo().bar()</code>，此时应该警惕是否违反了迪米特法则。</p>
<h4><a id="1-6-5%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%96%E8%88%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.6.5 实际运用中的取舍</h4>
<p>实际开发中，为了避免对象间的直接耦合，往往借助“Mediator”、“Proxy”等设计模式，引入中间人，拆开耦合。</p>
<h2><a id="%E4%BA%8C%E3%80%81gof%E7%9A%8423%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、GoF的23个设计模式</h2>
<blockquote>
<p>《Design Patterns Elements of Reusable Object-Oriented Software》</p>
</blockquote>
<p>作者介绍：</p>
<ul>
<li>Erich Gamma博士是瑞士苏黎士国际面向对象技术软件中心的技术主管。</li>
<li>Richard Helm博士是澳大利亚悉尼IBM顾问集团公司面向对象技术公司的成员。</li>
<li>Ralph Johnson博士是Urbana-Champaign伊利诺大学计算机科学系成员。</li>
<li>John Vlissides博士是位于纽约Hawthorne的IBN托马斯J.沃森研究中心的研究人员。</li>
</ul>
<h3><a id="2-1%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.1 创建型设计模式</h3>
<p>创建型模式用来解决对象的创建问题，用于解耦对象的使用者和对象的创建过程。</p>
<p>对象的使用者通常不应该包含创建复杂对象的逻辑，否则，对象的创建逻辑的变化会导致对象的使用者需要修改代码。</p>
<ol>
<li>Factory Method Pattern (工厂方法模式)</li>
<li>Abstract Factory Pattern (抽象工厂模式)</li>
<li>Singleton Pattern (单例模式)</li>
<li>Builder Pattern (建造者模式)</li>
<li>Prototype Pattern (原型模式)</li>
</ol>
<h3><a id="2-2%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.2 结构型设计模式</h3>
<p>结构型模式用来解决对象间的组合或组装的问题。用于简化客户端代码逻辑，使得客户端依赖的对象可以方便的扩展而不影响客户端。或节省客户端内存。</p>
<p>通常我们希望客户端使用其他对象的时候代码格外精简，优雅，而不是在使用前还要用大量的代码对目标对象做处理。因为这些对目标对象做处理的逻辑很可能发生变化，而这部分逻辑并不是客户端的业务职责。</p>
<ol>
<li>Proxy Pattern (代理模式)</li>
<li>Adapter Pattern (适配器模式)</li>
<li>Decorator Pattern (装饰器模式)</li>
<li>Facade Pattern (门面模式)</li>
<li>Composition Pattern (组合模式)</li>
<li>Flyweight Pattern (享元模式)</li>
<li>Bridge Pattern (桥接模式)</li>
</ol>
<h3><a id="3-3%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 行为型设计模式</h3>
<p>行为型模式解决的是对象之间交互方式的问题。</p>
<p>不适当的交互方式很容易产生不必要的耦合，使日后扩展受阻，不利于代码复用。</p>
<ol>
<li>Observer Pattern (观察者模式)</li>
<li>Template Method Pattern (模板方法模式)</li>
<li>Strategy Pattern (策略模式)</li>
<li>Chain of Responsibility Pattern (责任链模式)</li>
<li>State Pattern (状态模式)</li>
<li>Iterator Pattern (迭代器模式)</li>
<li>Visitor Pattern (访问者模式)</li>
<li>Memento Pattern (备忘录模式)</li>
<li>Command Pattern (命令模式)</li>
<li>Interpreter Pattern (解释器模式)</li>
<li>Mediator Pattern (中介模式)</li>
</ol>
<h2><a id="%E4%B8%89%E3%80%81the-12-factor-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、The 12-Factor App</h2>
<h3><a id="3-1-single-codebase%E5%9F%BA%E5%87%86%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 Single Codebase (基准代码)</h3>
<p>微服务之间不共享代码：多个微服务可以共享一个project，但每个微服务要有一个完整的代码仓库，且微服务之间没有公共的底层代码。</p>
<p>避免一个微服务修改代码影响其他微服务。</p>
<h3><a id="3-2-dependencies%E4%BE%9D%E8%B5%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 Dependencies (依赖)</h3>
<blockquote>
<p>显式声明依赖关系</p>
</blockquote>
<p>要显式声明依赖，且打包后使微服务自包含；不要假设微服务之外一定存在某个服务而不加依赖声明就去依赖。</p>
<p>避免微服务在不同环境间部署产生差异；使新人上手容易，拉出代码，使用构建工具打包后即可运行。</p>
<h3><a id="3-3-config%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 Config (配置)</h3>
<blockquote>
<p>在环境中存储配置</p>
</blockquote>
<p>微服务环境相关配置外置。微服务可以从外部拉取对应环境配置，使得微服务在构建之后在不同环境间切换时不用修改构建结果。</p>
<p>避免微服务在不同环境间部署时需要修改源代码引入意外bug，或忘记修改代码中配置导致部署失败。</p>
<h3><a id="3-4-backing-services%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.4 Backing Services (后端服务)</h3>
<blockquote>
<p>把后端服务当做附加资源</p>
</blockquote>
<p>微服务依赖的所有第三方服务都应该被视作一个资源，应该使用地址标识该资源，通过防腐层和依赖反转隔离微服务对外部资源的直接依赖，使得在不同环境只需要修改对应资源地址而不用修改代码即可和第三方服务对接，及时第三方服务的技术实现发生了变化微服务也不用修改代码。</p>
<p>避免在不同环境间部署微服务时，因为第三方服务地址不同或实现不同，版本不同而需要修改代码。</p>
<h3><a id="3-5-build-release-and-run%E6%9E%84%E5%BB%BA%EF%BC%8C%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%90%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.5 Build, Release and Run (构建，发布，运行)</h3>
<blockquote>
<p>严格分离构建和运行。</p>
</blockquote>
<p>微服务应该严格区分构建，发布和运行三个阶段。构建是从代码变成二进制的过程，和环境无关，而且不可再变；发布是给二进制加上对应环境的配置，在不同环境长需要使用相同的二进制和不同的环境配置重复发布；运行是在对应环境上启动进程。每个环境有各自的职责，禁止在运行阶段直接修改二进制。</p>
<p>避免微服务在上线过程中不同阶段引入不可预知bug。</p>
<h3><a id="3-6-processes%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.6 Processes (进程)</h3>
<blockquote>
<p>以一个或多个无状态进程运行应用</p>
</blockquote>
<p>微服务的每个实例都应该状态外置，存在缓存或DB中，使微服务实例自身无状态。可以任意水平扩容，负载均衡或代理可以把请求给到任意实例上。</p>
<p>避免无法水平扩容，避免单实例故障后丢失状态。</p>
<h3><a id="3-7-port-binding%E7%AB%AF%E5%8F%A3%E7%BB%91%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.7 Port Binding (端口绑定)</h3>
<blockquote>
<p>通过端口绑定来提供服务</p>
</blockquote>
<p>微服务不应该依赖任何已经存在的服务来对外提供网络服务，应该通过依赖服务提供程序形成自包含，微服务本身就可以对外提供网络服务。</p>
<p>避免网络服务提供能力依赖已存在的其他服务，导致如果其他服务不存在就无法提供网络服务。</p>
<h3><a id="3-8-concurrency%E5%B9%B6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.8 Concurrency (并发)</h3>
<blockquote>
<p>通过进程模型进行扩展</p>
</blockquote>
<p>每个微服务职责单一，不同微服务可根据流量分别水平扩容。微服务不要自己做进程管理。</p>
<p>避免导致微服务扩容的因素过多，造成浪费</p>
<h3><a id="3-9-disposable%E6%98%93%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.9 Disposable (易处理)</h3>
<blockquote>
<p>快速启动和优雅终止可最大化健壮性</p>
</blockquote>
<p>微服务应该追求最小启动时间和优雅的终止服务。优雅的终止服务意味着微服务接收到终止信号后首先关闭网络端口不再接收新的请求，而后继续处理已经接收的请求，最后终止服务。</p>
<p>避免因启动时间太长而影响对突发问题的响应能力。避免在重新调度微服务时由于不优雅终止服务而影响业务。</p>
<h3><a id="3-10-dev-prod-parity%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E7%AD%89%E4%BB%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.10 Dev / Prod Parity (开发环境和线上环境等价)</h3>
<blockquote>
<p>尽可能的保持开发、预发布、线上环境相同</p>
</blockquote>
<p>微服务应该反对在不同环境间使用不同的后端服务。</p>
<p>避免不同的后端服务突然出现的不兼容，导致测试、预发布都正常的代码在线上出现问题。</p>
<h3><a id="3-11-logs%E6%97%A5%E5%BF%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.11 Logs (日志)</h3>
<blockquote>
<p>把日志当做事件流</p>
</blockquote>
<p>微服务的日志应当被看作事件流，微服务不要自己管理日志存储，日志应当被日志汇聚底层基础设施统一的处理。</p>
<p>避免登录主机查看日志的麻烦，避免单实例故障导致日志丢失。避免历史事件的不可查询。</p>
<h3><a id="3-12-admin-processes%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.12  Admin Processes (管理进程)</h3>
<blockquote>
<p>后台管理任务当做一次性进程运行</p>
</blockquote>
<p>后台管理任务的代码随正常业务代码一同升级交付，后台管理任务使用不同的入口，一次性执行，但是基于正常业务的进程执行，两者使用相同的权限</p>
<p>避免管理任务的代码落后于业务代码导致无法使用，避免管理任务的权限超出正常业务进程，导致故障。</p>
<h2><a id="%E5%9B%9B%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%85%B3%E6%B3%A8%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、微服务设计关注点</h2>
<h3><a id="4-1%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 系统分层</h3>
<ul>
<li>后端微服务使用领域模型驱动开发模式</li>
<li>使用六边形或整洁架构作为代码的分层架构依据</li>
</ul>
<h3><a id="4-2%E6%8C%81%E4%B9%85%E5%B1%82%E8%AE%BE%E8%AE%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 持久层设计</h3>
<ul>
<li>禁止全表扫描操作，sql执行要有监控，持续优化慢sql</li>
<li>禁止把大量日志写入关系型数据库</li>
</ul>
<p>根据业务逻辑复杂度，对性能的诉求，可以考虑是用CQRS模式——即读写分离模式。读写分离模式分为数据库层面的读写分离——即主库用来写，从库用来读，和模型层面读写分离。模型层面读写分离针对写场景和读场景可以完全分开设计，模型可以完全不同，以便基于写和读场景的特定需求定制优化，数据库表结构也可以完全不同，甚至写和读场景使用完全不同的数据库产品，如写场景使用RDBMS，读场景使用NoSQL。</p>
<h3><a id="4-3%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 远程通信</h3>
<ul>
<li>服务注册、发现、负载均衡使用API Gateway，系统间通过API Gateway通信</li>
<li>系统暴露RestfulAPI给其他系统</li>
</ul>
<h3><a id="4-4%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.4 数据一致性</h3>
<ul>
<li>数据变更要同源，禁止同一个数据在两处变更然后同步</li>
<li>分布式系统随时可能出现故障而使一次请求失败，对于系统间通信场景，系统设计时要考虑各个环节异常的处理，如：
<ul>
<li>对方无法正常响应</li>
<li>对方已经接到请求，但是没来得及返回就挂了</li>
<li>接到对方返回，没来的及处理自己挂了</li>
<li>数据已经正常持久化，但是没能及时同步到其他副本，导致从其他副本读数据出现不一致</li>
</ul>
</li>
</ul>
<h3><a id="4-5%E6%80%A7%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.5 性能</h3>
<ul>
<li>消耗资源的服务要以非阻塞方式对外提供，接到请求先持久化，然后立即响应，任务执行完通过回调或消息通知方式通知调用方</li>
<li>禁止轮询的方式读取其他系统状态变化，也禁止通过api的方式提供资源状态变化查询服务，应该使用消息通知的方式</li>
<li>消耗资源较多的api要预估资源占用情况，不要一次调用就把内存耗尽，要有防御性设计，给运维留出余地</li>
<li>api设计要支持水平扩展，禁止绑定单台服务器处理任务，任务量上来后要可以通过扩容来降低单机压力</li>
<li>写日志等和主业务逻辑没有强依赖的步骤要做成异步的</li>
<li>对关键系统的写入操作要考虑是否有可能在某些条件下产生写入量突增，要做好预防，以免把关键系统写挂</li>
<li>上线新功能前要预估新功能对资源的需求增量，提前做好扩容准备</li>
</ul>
<h3><a id="4-6%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.6 依赖原则</h3>
<ul>
<li>依赖ID，或枚举，不允许依赖名称</li>
</ul>
<h3><a id="4-7%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.7 部署规范</h3>
<ul>
<li>每个组件一个IP，统一端口，不允许多个组件合部署在一个IP上</li>
</ul>
<h3><a id="4-8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BA%A4%E4%BB%98%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.8 架构设计交付件</h3>
<ul>
<li>系统关系图</li>
<li>组件关系图</li>
<li>业务逻辑图</li>
<li>部署架构图</li>
</ul>
<h2><a id="%E4%BA%94%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%88%90%E7%86%9F%E5%BA%A6%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、微服务设计成熟度衡量标准</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>度量项</th>
<th>参考文档</th>
</tr>
</thead>
<tbody>
<tr>
<td>API</td>
<td><div>API Rest成熟度</div><div>(使用Spring-HATEOAS提供可导航的API为4级最高级)</div></td>
<td></td>
</tr>
<tr>
<td>API</td>
<td>客户端代码自动生成</td>
<td></td>
</tr>
<tr>
<td>API</td>
<td>通过Swagger输出API文档</td>
<td></td>
</tr>
<tr>
<td>服务注册</td>
<td>服务自动注册发现</td>
<td></td>
</tr>
<tr>
<td>服务治理</td>
<td>接入API Gateway或Service mesh</td>
<td></td>
</tr>
<tr>
<td>配置</td>
<td>使用分布式动态配置</td>
<td></td>
</tr>
<tr>
<td>分布式事务</td>
<td>利用消息总线实现分布式事务最终一致性</td>
<td></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/3/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='architecture-designing.html'>架构设计</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15667988442443.html">
                
                  <h1>先天八卦</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-plain_text">            南
            乾1
        兑2      巽5
   东 离3     9      坎6 西        
        震4      艮7
             坤8
             北
</code></pre>
<p>乾三连、坤六段、震仰盂、艮覆碗、离中虚、坎中满、兑上缺、巽下断</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='yi.html'>易经</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15771157345073.html">
                
                  <h1>问题定位</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找问题线程</h2>
<ul>
<li>top 查看问题进程 pid</li>
<li>top -Hp pid 查看进程中有问题线程pid tid</li>
<li>printf '%x/n' tid 转化为十六进制</li>
<li>jstack pid |grep tid的十六进制 -A 30 查看线程堆栈信息</li>
</ul>
<h2><a id="%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存溢出问题</h2>
<ul>
<li>jstat -gcutil java_pid 刷新时间间隔 查看分区占用情况和gc状况</li>
<li>jmap -dump:format=b,file=name.dump java_pid  导出dump文件</li>
<li>用visualVM分析dump文件</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java.html'>Java</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15769237630512.html">
                
                  <h1>Docker Desktop for Mac 启动Kubernetes时查看日志方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre class="line-numbers"><code class="language-shell">pred='process matches &quot;.*(ocker|vpnkit).*&quot;
  || (process in {&quot;taskgated-helper&quot;, &quot;launchservicesd&quot;, &quot;kernel&quot;} &amp;&amp; eventMessage contains[c] &quot;docker&quot;)'
/usr/bin/log stream --style syslog --level=debug --color=always --predicate &quot;$pred&quot;
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='dev-ops.html'>DevOps</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15764895526219.html">
                
                  <h1>中国大陆地区安装minikube</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>由于众所周知的原因官方minikube在中国大陆地区运行会碰到网络问题。</p>
<p>阿里云对官方minikube做了修改，使它默认使用国内镜像仓库。安装和启动参考文档如下：</p>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/221687">Minikube - Kubernetes本地实验环境</a></p>
</blockquote>
<p>但是文中的参数任然有问题，如下命令可以正常启动，操作系统Mac</p>
<pre class="line-numbers"><code class="language-shell">minikube start --image-mirror-country cn \
    --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.5.1.iso \
    --registry-mirror=https://xxxxxx.mirror.aliyuncs.com \
    --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers
</code></pre>
<p>其中<code>--registry-mirror</code>参数中的&quot;xxxxxx&quot;是个人阿里云镜像加速地址，查询地址：</p>
<pre class="line-numbers"><code class="language-plain_text">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='dev-ops.html'>DevOps</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15750802883724.html">
                
                  <h1>平台到底是什么概念</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E8%88%AC%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一般定义</h2>
<p>平台能为产品团队提供可复用能力支撑（赋能），它是一个操作环境，可以让产品团队在其上把产品特性快速交付到客户手中。ThoughtWorks开发出一个五维模型来描述平台的重要特征：</p>
<ul>
<li>支持端到端交付的基础设施</li>
<li>API和架构自愈</li>
<li>提供自助服务</li>
<li>支持实验的基础设施</li>
<li>提供用户触点技术</li>
</ul>
<h2><a id="%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>先来看看什么不是一个平台</h2>
<h3><a id="%E6%8C%89%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E5%88%92%E5%88%86%E5%9B%A2%E9%98%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>按技术领域划分团队</h3>
<p>有的企业花大力气构建自动化能力，但是往往会根据技术划分团队。比如，负责中间件管理的团队，负责操作系统管理的团队，负责DB管理的团队，负责LB管理的团队，另外还会有一个专门负责自动化的效能团队，往往能力上只是负责编排。</p>
<p>这些团队，每个都在自己的管理架构下有独立的工作方式，每个团队都在各自的技术领域范围内实现高效率管理，集中专业化，外包非差异化功能，应用治理，并降低成本。但就是没人去衡量客户需求端到端的交付效率。</p>
<p>一个客户需求的交付往往穿越多个团队，端到端交付效率极差。</p>
<p>时间长了，产品和基础设施的质量逐渐下降。环境和配置上会出现很多细微的不一致。产品团队不得不降低交付速度，减少一次交付包含的特性。甚至不敢去做任何改动较大的提升动作或重构动作，而这些动作本来是用来改善问题的。</p>
<h3><a id="%E5%BD%BC%E6%AD%A4%E4%BE%9D%E8%B5%96%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>彼此依赖的待办事项</h3>
<p>一个特性的交付往往在一个团队内无法独立完成，于是一个团队的待办事项会依赖其他团队的待办事项，彼此耦合。而往往不同团队有不同的目标，各自的待办事项优先级不同。于是一个团队的待办事项无法落地的原因往往就是依赖另一个团队的待办事项，而另一个团队迟迟不能完成。这就造成了团队之间的隔阂和互相之间的不信任，甚至扯皮、推诿，丧失责任感和创造力。最终使端到端交付的效率变得极低。</p>
<p>显然，一个好的平台的一个重要特征是，他必须能减少待办事项耦合。该平台必须能够支持自助服务。</p>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是一个平台</h2>
<p>AWS就是一个平台。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何构建一个平台</h2>
<ol>
<li>调整组织架构，给每个产品团队增加5%的运维职责，节省平台团队200%的运维职责。&quot;you build it, you run it.&quot;</li>
<li>平台自己也要承担从开发到运行的所有责任，避免平台自身的开发团队只管开发，运维团队管运行。同样要坚守：&quot;you build it, you run it.&quot;</li>
<li>划清平台和产品团队的职责边界，产品团队负责自己产品的构建，部署，监控等；平台团队负责平台的构建，部署，监控等；设计抽象，对外暴露自助服务；平台不应该关心它上面跑的是什么业务，产品不应该关心平台使用的技术。</li>
<li>除了提供API之外，还要提供文档，guideline, template code, on call, 布道等。</li>
<li>最初落地时不知道需要提供哪些能力，可以从产品团队了解需求，从解决最迫切的需求开始。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='dev-ops.html'>DevOps</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15749287286754.html">
                
                  <h1>Immutable Infrastructure</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFmutable-infrastructure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是Mutable Infrastructure</h2>
<p>传统物理服务器时代，企业倾向于对服务器做修改以实现商业目的。如，更换配件，原地更新软件包(upgrade app)，修改配置(update configuration)，打补丁(ad-hoc fixes)，微调(tweaks)。这些操作渐渐把一个服务器变得独一无二(<a href="https://martinfowler.com/bliki/SnowflakeServer.html">SnowflakeServer</a>)。这使得它难以被替换，难以维护，难以复制。你越来越无法理解其上面的某个配置这样配的原因。而这一切之所以会这样发展，是因为物理服务器时代服务器更新的难度大，成本高，周期长。所以企业在服务器更新上发展出很多技术，但都是围绕着原地升级的思路发展的。</p>
<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFimmutable-infrastructure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是Immutable Infrastructure</h2>
<p>到了虚拟化时代，虚拟服务器变得可以被轻易替换(disposable)，整个服务器可以在秒级被重新构建。这使得使用服务器被整体替换的方式更新服务器比原地升级服务器来的更划算。服务器一旦部署完就不再被修改，服务器需要升级时，是基于一个基线重新构建然后替换原有服务器。这使得服务器的复制，替换变得轻而易举。这种服务器也叫<a href="https://martinfowler.com/bliki/PhoenixServer.html">PhoenixServer</a>。这样的基础架构无疑更加健壮，可维护。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0immutable-infrastructure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何实现Immutable Infrastructure</h2>
<ul>
<li>禁止人工登录服务器做任何修改</li>
<li>使用虚拟化技术</li>
<li>服务器可以基于镜像快速构建，</li>
<li>服务器的生命周期管理由软件自动化实现
<ul>
<li>服务器目标状态由文档定义</li>
<li>文档由VCS管理</li>
<li>服务器更新由自动化工具基于VCS里文档的更新触发，并最终实现目标状态</li>
</ul>
</li>
<li>一个无状态，变化频繁的应用层</li>
<li>一个数据持久层
<ul>
<li>日志中心，记录服务器的每次变更</li>
<li>外部数据存储，无状态应用层服务器被频繁替换，数据必须存储在外部</li>
</ul>
</li>
<li>开发和运维无间合作(DevOps)</li>
<li>使用混沌工程工具验证服务的健壮性</li>
</ul>
<h2><a id="%E7%90%86%E6%83%B3%E5%BE%88%E4%B8%B0%E6%BB%A1%EF%BC%8C%E7%8E%B0%E5%AE%9E%E5%BE%88%E9%AA%A8%E6%84%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理想很丰满，现实很骨感</h2>
<p>如果在物理服务器上利用严格规范和自动化工具是否能打造Immutable Infrastructure呢？理论上可以，但现实是物理服务器很多场景下难以实现批量统一的更新，因为物理服务器太大，上面跑的东西太多。<br />
那么是不是使用了虚拟化技术，就一定能实现Immutable Infrastructure？答案是否定的。国内很多大厂，甚至是云计算提供商，其内部服务虽然使用了虚拟机，甚至容器，但是其运维范式仍然遵循传统原地升级模式，仍然会登录到虚拟机或容器内部做一些修改，或者只有部分技术栈（如服务软件包，基础软件包）实现了基线化管理，而其他技术栈（如操作系统配置，网络配置）还是通过其他途径手动升级，整体效果仍然和传统Mutable Infrastructure一样。举个例子，应用扩容一台机器，而防火墙没有同步更新，导致新扩容的服务器和其他服务器之间网络不通，需要人工修改网络配置才能打通网络。<br />
所以说，真正的Immutable Infrastructure的落地，是依赖强有力的运维能力的，而这样的运维能力又依赖配套的组织架构关系和DevOps文化和极强的规范化。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/11/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='dev-ops.html'>DevOps</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15667991314468.html">
                
                  <h1>后天八卦</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>乾坎艮震巽离坤兑</p>
<table>
<thead>
<tr>
<th>食指</th>
<th>中指</th>
<th>无名指</th>
</tr>
</thead>
<tbody>
<tr>
<td>巽4</td>
<td>离9</td>
<td>坤2</td>
</tr>
<tr>
<td>震3</td>
<td>5</td>
<td>兑7</td>
</tr>
<tr>
<td>艮8</td>
<td>坎1</td>
<td>乾6</td>
</tr>
</tbody>
</table>
<p>戴九履一，左三右七，二四为肩，六八为足，五居其中</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='yi.html'>易经</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15621674595097.html">
                
                  <h1>Kafka学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="kafka%E5%90%8D%E5%AD%97%E6%9D%A5%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka名字来源</h2>
<p>Kafka作者之一Jay Kreps曾经谈及过命名的原因：</p>
<blockquote>
<p>因为 Kafka 系统的写性能很强，所以找了个作家的名字来命名似乎是一个好主意。大学期间我上了很多文学课，非常喜欢 Franz Kafka 这个作家，另外为开源软件起这个名字听上去很酷。</p>
</blockquote>
<h2><a id="kafka%E7%9A%84%E5%AE%9A%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka的定位</h2>
<p>Kafka 是 LinkedIn 公司内部孵化的项目。</p>
<p>Kafka 在设计之初就旨在提供三个方面的特性：</p>
<ul>
<li>提供一套 API 实现生产者和消费者；</li>
<li>降低网络传输和磁盘存储开销；</li>
<li>实现高伸缩性架构。</li>
</ul>
<p>Kafka既是消息引擎系统，也是一个分布式流处理平台。</p>
<h3><a id="kafka%E4%BD%9C%E4%B8%BA%E6%B5%81%E5%A4%84%E7%90%86%E5%B9%B3%E5%8F%B0%E5%92%8C%E5%85%B6%E4%BB%96%E4%B8%BB%E6%B5%81%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%E7%9B%B8%E6%AF%94%E7%9A%84%E4%BC%98%E5%8A%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka作为流处理平台和其他主流计算框架相比的优势</h3>
<ul>
<li>更容易实现端到端的正确性（精确一次处理语义）</li>
<li>Kafka Streams宣称自己是一个用于搭建流处理的客户端库，而非完整功能系统，有利于区别其他框架的目标市场（瞄准小公司）</li>
</ul>
<h2><a id="kafka%E6%9C%AF%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kafka术语</h2>
<h3><a id="%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%98%8Ekafka%E6%9C%AF%E8%AF%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一张图说明Kafka术语</h3>
<p><img src="http://image.harveygg.wang/mweb/15621685649048.jpg" alt="" style="width:1171px;" /></p>
<ul>
<li>消息（Record）：消息引擎处理的主要对象</li>
<li>主题（Topic）：承载消息的逻辑容器，具体使用中用于区分业务</li>
<li>分区（Partition）：一个有序的消息队列，一个主题下可以有多个分区</li>
<li>消息位移（Offset）：表示分区中每条消息的位置，是一个单调递增不变的值</li>
<li>副本（Replica）：Kafka中一条消息可以被复制到多个地方实现数据冗余，这些地方就是副本。副本还分leader副本和follower副本。副本在分区的层级下，一个分区可以配置多个副本实现数据高可靠</li>
<li>生产者（Producer）：向主题发布新消息的应用程序</li>
<li>消费者（Consumer）：从主题订阅新消息的应用程序</li>
<li>消费者位移（Consumer Offset）：表征消费者的消费进度，每个消费者都有自己的消费者位移</li>
<li>消费者组（Consumer Group）：多个消费者实例共同构成一个组，同时消费多个分区实现高吞吐</li>
<li>重平衡（Rebalance）：消费者组内一个消费者实例挂掉后，其他消费者自动重新分配订阅主题分区的过程。Rebalance是Kafka实现消费者端高可用的手段</li>
</ul>
<h2><a id="%E4%B8%8D%E8%83%BD%E4%BF%9D%E6%8C%81%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不能保持默认值的参数</h2>
<h3><a id="broker%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Broker端参数</h3>
<ul>
<li>log.dirs：没有默认值，必须手动指定。CVS格式指定多个路径，且多个路径最好分布在不同磁盘上，提供读写性能和提高可用性</li>
<li>listeners：监听器，告诉外部连接者要用什么协议访问主机和端口开放的Kafka服务</li>
<li>advertised.listeners：这组监听器是Broker用于对外发布的</li>
<li>auto.create.topics.enable：配置为true时表示，当收到消息，发现所属主题不存在时则自动创建，建议生产配置false</li>
<li>unclean.leader.election.enable：是否允许unclean leader选举。是指落后最新消息的partition被选举为leader的许可。若配置为true，则有可能导致消息丢失</li>
<li>auto.leader.rebalance.enable：是否允许定期重新选举leader，没必要，且对生产环境影响非常大，建议配置false</li>
<li>log.retention.{hour|minutes|ms}：三个配置都是用来控制一条消息被保存多长时间，ms优先级最高，hour最低</li>
<li>log.retention.bytes：指Broker为消息保存的总磁盘容量大小，默认值-1，标识存多少都行</li>
<li>message.max.bytes：Broker能接收的最大消息大小</li>
</ul>
<h3><a id="topic%E7%BA%A7%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Topic级参数</h3>
<ul>
<li>retention.ms：规定了该topic消息被保存的时长，默认7天，优先级高于Broker配置</li>
<li>retention.bytes：规定了该topic预留多少磁盘空间</li>
<li>message.max.bytes：该topic下单条消息最大尺寸，可用于不同业务不同配置</li>
</ul>
<h3><a id="producer%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producer端参数</h3>
<h3><a id="consumer%E7%AB%AF%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consumer端参数</h3>
<h3><a id="jvm%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM参数</h3>
<blockquote>
<p>设置环境变量，提高JVM堆大小，业界公认最佳配置为6G，修改GC算法</p>
</blockquote>
<ul>
<li>KAFKA_HEAP_OPTS：堆大小</li>
<li>KAFKA_JVM_PERFORMANCE_OPTS：GC算法</li>
</ul>
<pre class="line-numbers"><code class="language-shell">$&gt; export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g
$&gt; export  KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true
$&gt; bin/kafka-server-start.sh config/server.properties

</code></pre>
<h3><a id="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>操作系统参数</h3>
<ul>
<li>文件描述符限制调大</li>
<li>文件系统类型：根据官网的测试报告，XFS 的性能要强于 ext4，<a href="https://www.confluent.io/kafka-summit-sf18/kafka-on-zfs">ZFS</a>性能貌似更好</li>
<li>Swap修改成1：改成0容易导致内存溢出来不及处理</li>
<li>文件刷盘时间间隔：消息写到页缓存上即算成功，减小刷盘间隔可以提高可用性，但是降低吞吐量</li>
</ul>
<h2><a id="%E5%AE%9E%E7%8E%B0%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现无消息丢失</h2>
<h3><a id="%E9%85%8D%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置最佳实践</h3>
<ol>
<li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</li>
<li>设置 acks = all。acks 是 Producer的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li>
<li>设置 retries 为一个较大的值。这里的 retries同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li>
<li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li>
<li>设置 replication.factor &gt;= 3。这也是Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li>
<li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li>
<li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li>
</ol>
<h3><a id="%E5%B8%B8%E8%A7%81%E4%B8%A2%E6%B6%88%E6%81%AF%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见丢消息案例</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/7/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='middleware.html'>中间件</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15611719436274.html">
                
                  <h1>域名解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="dns%E5%9F%9F%E5%90%8D%E8%A7%84%E8%8C%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS域名规范</h2>
<ul>
<li>域名中的标号由英文和数字组成，标号中除连字符“-”外不能使用其他的标点符号，不区分大小写字母</li>
<li>每一个标号不超过63个字符</li>
<li>级别最低的域名写在最左边，而级别最高的字符写在最右边</li>
<li>由多个标号组成的完整域名总共不超过255个字符</li>
<li>DNS既不规定一个域名需要包含多少个下级域名，也不规定每一级域名代表什么意思。</li>
<li>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由ICANN进行管理</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名管理</h2>
<ul>
<li>
<p>顶级域名分三大类</p>
<ul>
<li><strong>国家顶级域名nTLD</strong>：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)</li>
<li><strong>通用顶级域名gTLD</strong>：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)</li>
<li><strong>基础结构域名(infrastructure domain)</strong>：只有一个arpa，用于反向域名解析，因此成为反向域名</li>
</ul>
<p><img src="http://image.harveygg.wang/mweb/15611724903244.jpg" alt="xxx" /></p>
</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名服务器的分类</h2>
<ul>
<li>根域名服务器：记录顶级域名服务器</li>
<li>顶级域名服务器：管理在该顶级域名服务器注册的二级域名</li>
<li>权威域名服务器(authoritative domain name system)：负责一个zone的域名解析</li>
<li>本地域名服务器：不在域名服务器树结构中，但是很重要，域名解析首先发给本地域名服务器</li>
</ul>
<h2><a id="%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>域名解析过程</h2>
<ol>
<li>请求本地域名服务器</li>
<li>本地域名服务器返回解析结果或想根域名服务器请求</li>
<li>根域名服务器返回顶级域名服务器的地址</li>
<li>本地域名服务器请求顶级域名服务器</li>
<li>顶级域名服务器返回权威域名服务器的地址</li>
<li>本地域名服务器请求权威域名服务器</li>
<li>权威域名服务器返回解析结果或报错</li>
<li>本地域名服务器返回解析结果或报错</li>
</ol>
<h2><a id="dns%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DNS记录类型</h2>
<ul>
<li>A记录：将域名指向IPv4地址</li>
<li>AAAA：将域名指向IPv6地址（例如：ff06:0:0:0:0:0:0:c3）</li>
<li>CNAME：将域名指向另一个域名</li>
<li>TXT：在这里可以填写任何东西，长度限制255字符。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）</li>
<li>NS：授权其他域名服务器解析域名</li>
<li>MX：指向邮箱服务器</li>
<li>SOA：SOA叫做起始授权机构记录，表明负责一个zone的多台权威DNS服务器（由NS记录标记）之间的关系，SOA指向的DNS有修改权，其他DNS从SOA同步数据</li>
<li>SRV记录：记录提供特定服务的服务器，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</li>
<li>PTR记录：PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='internet-tech.html'>互联网技术</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15587920075778.html">
                
                  <h1>(1) MAC开发环境——软件包管理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<hr />
<h2><a id="homebrew-https-brew-sh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://brew.sh/">Homebrew</a></h2>
<p><img src="http://image.harveygg.wang/mweb/homebrew-256x256.png" alt="homebrew-256x256" /></p>
<ul>
<li>使用 Homebrew 安装 Apple 没有预装，但你需要的东西。</li>
<li>brew管理命令行工具，三方库，会先下载源码，编译，安装，最后link到/usr/local/bin中，如：<code>brew install wget</code></li>
<li>brew cask管理Mac应用，会直接下载二进制，然后安装，是AppStore的补充，如：<code>brew cask install chrome</code></li>
<li>推荐所有软件<strong>先考虑AppStore</strong>，如果没有<strong>再考虑Homebrew</strong>，再没有<strong>再去官网下载</strong>，方便后面管理</li>
</ul>
<h3><a id="install-homebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Install Homebrew</h3>
<pre class="line-numbers"><code class="language-shell">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>
<h3><a id="homebrew%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew 常用命令</h3>
<pre class="line-numbers"><code class="language-shell">$ brew search /wge*/  # 搜索软件,后面是正则表达式
$ brew info wget    # 查看软件信息
$ brew install wget  # 安装 wget
$ brew list wget    # 列出该软件安装后的文件
$ brew uninstall wget  # 卸载 wget
</code></pre>
<h3><a id="%E8%8E%B7%E5%8F%96homebrew-cask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取Homebrew-Cask</h3>
<pre class="line-numbers"><code class="language-shell">$ brew tap caskroom/cask
</code></pre>
<h3><a id="homebrew-cask%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew Cask常用命令</h3>
<pre class="line-numbers"><code class="language-shell"># brew cask 和 brew 的命令基本一致，search, info, list, install, uninstall 子命令都一样
$ brew cask install java  # 安装 Java
$ brew cask uninstall java  # 卸载 Java
$ brew cask install --force $(brew cask outdated | awk '{print $1}' | xargs)  # 更新Cask
</code></pre>
<h3><a id="homebrew%E6%9B%B4%E5%A4%9A%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Homebrew 更多命令</h3>
<pre class="line-numbers"><code class="language-shell">$ brew cleanup  # 卸载旧版本软件，Homebrew升级时是全新安装，不卸载旧版，需要手动卸载旧版本软件
$ brew update  # 更新Homebrew
$ brew upgrade  # 更新所有过期软件
$ brew doctor  # brew自检
$ brew outdated  # 列出所有过期软件
$ brew --cache  # 打印brew下载包存放位置
</code></pre>
<h3><a id="%E5%8D%B8%E8%BD%BDhomebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>卸载Homebrew</h3>
<pre class="line-numbers"><code class="language-shell">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)
</code></pre>
<p>Download the uninstall script and run ./uninstall --help to view more uninstall options.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mac-dev-env.html'>Mac开发环境</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://media-exp1.licdn.com/dms/image/C5103AQEbVyw8R1s-0Q/profile-displayphoto-shrink_200_200/0/1570421197030?e=1627516800&v=beta&t=BNSCoU699ikE6Jr9Vz0-wvTSAm7eykQSaL7ZwoEdGsM" /></div>
            
                <h1>Harvey's Tech Site</h1>
                <div class="site-des">多年互联网电商行业开发经验、云计算SRE开发经验。关注DDD，云原生，DevOps。正在学习机器学习、人工智能</div>
                <div class="social">
<a target="_blank" class="facebook" href="https://www.facebook.com/profile.php?id=100000085231645" title="Facebook">Facebook</a>

<a target="_blank" class="stackoverflow" href="https://stackoverflow.com/users/11747959/harvey-wang" title="StackOverflow"></a>
<a target="_blank" class="linkedin" href="https://www.linkedin.com/in/harveywhy/" title="LinkedIn">LinkedIn</a>
<a target="_blank" class="pinterest" href="https://www.pinterest.com/harveywanghy/" title="Pinterest">Pinterest</a>

<a target="_blank" class="instagram" href="https://www.instagram.com/harveyvan82/" title="Instagram">Instagram</a>

<a target="_blank" class="twitter" target="_blank" href="https://twitter.com/Harvey_DDD" title="Twitter">Twitter</a>
<a target="_blank" class="github" target="_blank" href="https://github.com/HarveyGG" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:harvey.wanghy@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="mac-dev-env.html"><strong>Mac开发环境</strong></a>
        
            <a href="internet-tech.html"><strong>互联网技术</strong></a>
        
            <a href="architecture-designing.html"><strong>架构设计</strong></a>
        
            <a href="middleware.html"><strong>中间件</strong></a>
        
            <a href="yi.html"><strong>易经</strong></a>
        
            <a href="dev-ops.html"><strong>DevOps</strong></a>
        
            <a href="java.html"><strong>Java</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16237800130779.html">Linux运维常用命令组合</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15616863130414.html">MAC使用技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16143819545361.html">各种Branching Model，workflow的比较思路和推荐小团队使用的精简有效的workflow</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16129809371350.html">(3) 我的MAC开发环境</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15961083014557.html">vim实用高级命令</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
